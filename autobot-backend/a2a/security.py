# AutoBot - AI-Powered Automation Platform
# Copyright (c) 2025 mrveiss
# Author: mrveiss
"""
A2A Security Cards â€” agent identity verification.

Issue #968: Addresses A2A rug-pull attack vector identified in Semgrep/Solo.io
security research. An HMAC-signed security card lets any caller verify that
an Agent Card was genuinely issued by this AutoBot instance and has not been
tampered with.

Protocol reference:
  https://a2a-protocol.org/latest/topics/security/

Usage:
    card_dict  = build_agent_card(base_url).to_dict()
    signed     = SecurityCardSigner.sign(card_dict)
    # Receiver verifies:
    SecurityCardSigner.verify(signed)  # raises ValueError on failure
"""

import hashlib
import hmac
import json
import logging
import os
import time
from typing import Any, Dict

logger = logging.getLogger(__name__)

# Secret loaded once at module import.  In production this must be set via
# the AUTOBOT_A2A_SECRET env var (generated by Ansible and stored in .env).
_SECRET = os.environ.get("AUTOBOT_A2A_SECRET", "")

# How long a signed card is considered fresh (seconds).
_CARD_TTL = int(os.environ.get("AUTOBOT_A2A_CARD_TTL", "3600"))


def _get_secret() -> bytes:
    """Return the signing secret as bytes.  Raises RuntimeError if unset."""
    if not _SECRET:
        raise RuntimeError(
            "AUTOBOT_A2A_SECRET is not set. "
            "Set it in .env or via the Ansible backend role."
        )
    return _SECRET.encode()


class SecurityCardSigner:
    """HMAC-SHA256 signer/verifier for A2A security cards."""

    @staticmethod
    def sign(card: Dict[str, Any]) -> Dict[str, Any]:
        """
        Attach an HMAC-SHA256 signature and issued_at timestamp to a card dict.

        The signature covers the canonical JSON representation of the card
        plus the timestamp so replayed old cards are rejected.

        Args:
            card: Agent card dict (from AgentCard.to_dict())

        Returns:
            New dict containing the original card under 'card', plus
            'issued_at' (Unix epoch int) and 'signature' (hex string).

        Raises:
            RuntimeError: If AUTOBOT_A2A_SECRET is not configured.
        """
        issued_at = int(time.time())
        payload = _canonical_payload(card, issued_at)
        sig = _hmac_sign(payload)
        return {
            "card": card,
            "issued_at": issued_at,
            "signature": sig,
        }

    @staticmethod
    def verify(signed: Dict[str, Any]) -> Dict[str, Any]:
        """
        Verify a signed card and return the inner card dict on success.

        Checks:
          1. Signature integrity (HMAC constant-time compare)
          2. Freshness (issued_at + TTL must be in the future)

        Args:
            signed: Dict with keys 'card', 'issued_at', 'signature'

        Returns:
            The inner 'card' dict if valid.

        Raises:
            ValueError: If signature is invalid, card is stale, or fields missing.
            RuntimeError: If AUTOBOT_A2A_SECRET is not configured.
        """
        _check_required_fields(signed)
        card = signed["card"]
        issued_at = signed["issued_at"]
        expected_sig = signed["signature"]

        payload = _canonical_payload(card, issued_at)
        actual_sig = _hmac_sign(payload)

        if not hmac.compare_digest(actual_sig, expected_sig):
            logger.warning("A2A security card signature mismatch")
            raise ValueError("Invalid security card signature")

        age = int(time.time()) - issued_at
        if age > _CARD_TTL:
            logger.warning(
                "A2A security card expired (age=%ds, ttl=%ds)", age, _CARD_TTL
            )
            raise ValueError(f"Security card expired (age {age}s > ttl {_CARD_TTL}s)")

        logger.debug("A2A security card verified (age=%ds)", age)
        return card


def _canonical_payload(card: Dict[str, Any], issued_at: int) -> bytes:
    """Produce a deterministic bytes payload for signing."""
    blob = json.dumps(card, sort_keys=True, separators=(",", ":"))
    return f"{issued_at}:{blob}".encode()


def _hmac_sign(payload: bytes) -> str:
    """Return the HMAC-SHA256 hex digest of payload."""
    return hmac.new(_get_secret(), payload, hashlib.sha256).hexdigest()


def _check_required_fields(signed: Dict[str, Any]) -> None:
    """Raise ValueError if any required field is missing."""
    for field in ("card", "issued_at", "signature"):
        if field not in signed:
            raise ValueError(f"Signed card missing field: {field!r}")
