<template>
  <ErrorBoundary fallback="Settings panel failed to load.">
    <div class="settings-panel">
    <h2>Settings</h2>
    <div class="settings-tabs">
      <button
        v-for="tab in tabs"
        :key="tab.id"
        :class="{ active: activeTab === tab.id }"
        @click="activeTab = tab.id"
       :aria-label="tab.label">
        {{ tab.label }}
      </button>
    </div>
    <div class="settings-content">
      <!-- Loading indicator -->
      <div v-if="settingsLoadingStatus === 'loading'" class="settings-loading">
        <div class="loading-spinner"></div>
        <p>Loading settings...</p>
      </div>

      <!-- Settings status message -->
      <div v-if="settingsLoadingStatus === 'offline'" class="settings-status offline">
        <i class="fas fa-exclamation-triangle"></i>
        <span>Backend offline - using cached settings</span>
      </div>

      <!-- Chat Settings -->
      <div v-if="activeTab === 'chat' && settings.chat && isSettingsLoaded" class="settings-section">
        <h3>Chat Settings</h3>
        <div class="setting-item">
          <label>Auto Scroll to Bottom</label>
          <input type="checkbox" v-model="settings.chat.auto_scroll" />
        </div>
        <div class="setting-item">
          <label>Max Messages</label>
          <input type="number" v-model="settings.chat.max_messages" min="10" max="1000" />
        </div>
        <div class="setting-item">
          <label>Message Retention (Days)</label>
          <input type="number" v-model="settings.chat.message_retention_days" min="1" max="365" />
        </div>
      </div>

      <!-- Backend Settings -->
      <div v-if="activeTab === 'backend' && isSettingsLoaded" class="settings-section">
        <div class="sub-tabs">
          <button
            :class="{ active: activeBackendSubTab === 'general' }"
            @click="activeBackendSubTab = 'general'"
           aria-label="General">
            General
          </button>
          <button
            :class="{ active: activeBackendSubTab === 'llm' }"
            @click="activeBackendSubTab = 'llm'"
           aria-label="Llm">
            LLM
          </button>
          <button
            :class="{ active: activeBackendSubTab === 'embedding' }"
            @click="activeBackendSubTab = 'embedding'"
           aria-label="Embedding">
            Embedding
          </button>
          <button
            :class="{ active: activeBackendSubTab === 'memory' }"
            @click="activeBackendSubTab = 'memory'"
           aria-label="Memory">
            Memory
          </button>
        </div>
        <div v-if="activeBackendSubTab === 'general'" class="sub-tab-content">
          <h3>Backend General Settings</h3>
          <div class="setting-item">
            <label>API Endpoint</label>
            <input type="text" v-model="settings.backend.api_endpoint" />
          </div>
          <div class="setting-item">
            <label>Server Host</label>
            <input type="text" v-model="settings.backend.server_host" />
          </div>
          <div class="setting-item">
            <label>Server Port</label>
            <input type="number" v-model="settings.backend.server_port" min="1" max="65535" />
          </div>
          <div class="setting-item">
            <label>Chat Data Directory</label>
            <input type="text" v-model="settings.backend.chat_data_dir" />
          </div>
          <div class="setting-item">
            <label>Chat History File</label>
            <input type="text" v-model="settings.backend.chat_history_file" placeholder="data/chat_history.json" />
          </div>
          <div class="setting-item">
            <label>Knowledge Base DB</label>
            <input type="text" v-model="settings.backend.knowledge_base_db" placeholder="data/knowledge_base.db" />
          </div>
          <div class="setting-item">
            <label>Reliability Stats File</label>
            <input type="text" v-model="settings.backend.reliability_stats_file" placeholder="data/reliability_stats.json" />
          </div>
          <div class="setting-item">
            <label>Audit Log File</label>
            <input type="text" v-model="settings.backend.audit_log_file" placeholder="data/audit.log" />
          </div>
          <div class="setting-item">
            <label>CORS Origins (comma separated)</label>
            <input type="text" v-model="corsOriginsString" />
          </div>
        </div>
        <div v-if="activeBackendSubTab === 'llm'" class="sub-tab-content">
          <h3>LLM Settings</h3>
          <div class="setting-item">
            <label>Current LLM Status</label>
            <div class="llm-status-display">
              <div class="status-line">
                <span class="status-label">Connection:</span>
                <span :class="['status-value', healthStatus.llm.connected ? 'connected' : 'disconnected']">
                  {{ healthStatus.llm.connected ? 'Connected' : 'Disconnected' }}
                </span>
              </div>
              <div class="status-line" v-if="healthStatus.llm.connected && healthStatus.llm.current_model">
                <span class="status-label">Active Model:</span>
                <span class="status-value">{{ healthStatus.llm.current_model }}</span>
              </div>
              <div class="status-line">
                <span class="status-label">Configured:</span>
                <span class="status-value">{{ getCurrentLLMConfig() }}</span>
              </div>
            </div>
          </div>
          <div class="setting-item">
            <label>Provider Type</label>
            <select v-model="settings.backend.llm.provider_type" @change="onProviderTypeChange">
              <option value="local">Local LLM</option>
              <option value="cloud">Cloud LLM</option>
            </select>
          </div>
          <div v-if="settings.backend.llm.provider_type === 'local'">
            <div class="setting-item">
              <label>Local Provider</label>
              <select v-model="settings.backend.llm.local.provider" @change="onLocalProviderChange">
                <option value="ollama">Ollama</option>
                <option value="lmstudio">LM Studio</option>
              </select>
            </div>
            <div v-if="settings.backend.llm.local.provider === 'ollama'">
              <div class="setting-item">
                <label>Ollama Endpoint</label>
                <input type="text" v-model="settings.backend.llm.local.providers.ollama.endpoint" />
              </div>
              <div class="setting-item">
                <label>Model</label>
                <select v-model="settings.backend.llm.local.providers.ollama.selected_model" @change="notifyBackendOfProviderChange">
                  <option v-for="model in settings.backend.llm.local.providers.ollama.models" :key="model" :value="model">{{ model }}</option>
                </select>
              </div>
            </div>
            <div v-else-if="settings.backend.llm.local.provider === 'lmstudio'">
              <div class="setting-item">
                <label>LM Studio Endpoint</label>
                <input type="text" v-model="settings.backend.llm.local.providers.lmstudio.endpoint" />
              </div>
              <div class="setting-item">
                <label>Model</label>
                <select v-model="settings.backend.llm.local.providers.lmstudio.selected_model" @change="notifyBackendOfProviderChange">
                  <option v-for="model in settings.backend.llm.local.providers.lmstudio.models" :key="model" :value="model">{{ model }}</option>
                </select>
              </div>
            </div>
          </div>
          <div v-else-if="settings.backend.llm.provider_type === 'cloud'">
            <div class="setting-item">
              <label>Cloud Provider</label>
              <select v-model="settings.backend.llm.cloud.provider" @change="onCloudProviderChange">
                <option value="openai">OpenAI</option>
                <option value="anthropic">Anthropic</option>
              </select>
            </div>
            <div v-if="settings.backend.llm.cloud.provider === 'openai'">
              <div class="setting-item">
                <label>API Key</label>
                <input type="password" v-model="settings.backend.llm.cloud.providers.openai.api_key" placeholder="Enter API Key" />
              </div>
              <div class="setting-item">
                <label>Endpoint</label>
                <input type="text" v-model="settings.backend.llm.cloud.providers.openai.endpoint" />
              </div>
              <div class="setting-item">
                <label>Model</label>
                <select v-model="settings.backend.llm.cloud.providers.openai.selected_model" @change="notifyBackendOfProviderChange">
                  <option v-for="model in settings.backend.llm.cloud.providers.openai.models" :key="model" :value="model">{{ model }}</option>
                </select>
              </div>
            </div>
            <div v-else-if="settings.backend.llm.cloud.provider === 'anthropic'">
              <div class="setting-item">
                <label>API Key</label>
                <input type="password" v-model="settings.backend.llm.cloud.providers.anthropic.api_key" placeholder="Enter API Key" />
              </div>
              <div class="setting-item">
                <label>Endpoint</label>
                <input type="text" v-model="settings.backend.llm.cloud.providers.anthropic.endpoint" />
              </div>
              <div class="setting-item">
                <label>Model</label>
                <select v-model="settings.backend.llm.cloud.providers.anthropic.selected_model" @change="notifyBackendOfProviderChange">
                  <option v-for="model in settings.backend.llm.cloud.providers.anthropic.models" :key="model" :value="model">{{ model }}</option>
                </select>
              </div>
            </div>
          </div>
          <div class="setting-item">
            <label>Timeout (seconds)</label>
            <input type="number" v-model="settings.backend.timeout" min="10" max="300" />
          </div>
          <div class="setting-item">
            <label>Max Retries</label>
            <input type="number" v-model="settings.backend.max_retries" min="1" max="10" />
          </div>
          <div class="setting-item">
            <label>Enable Streaming</label>
            <input type="checkbox" v-model="settings.backend.streaming" @change="notifyBackendOfProviderChange" />
          </div>
          <div class="settings-actions">
            <button @click="loadModels" aria-label="Refresh models">Refresh Models</button>
          </div>
        </div>
        <div v-if="activeBackendSubTab === 'embedding'" class="sub-tab-content">
          <h3>Embedding Model Settings</h3>
          <div class="setting-item">
            <label>Current Embedding Model Status</label>
            <div class="embedding-status-display">
              <div class="status-line">
                <span class="status-label">Connection:</span>
                <span :class="['status-value', healthStatus.embedding?.connected ? 'connected' : 'disconnected']">
                  {{ healthStatus.embedding?.connected ? 'Connected' : 'Disconnected' }}
                </span>
              </div>
              <div class="status-line" v-if="healthStatus.embedding?.connected && healthStatus.embedding?.current_model">
                <span class="status-label">Active Model:</span>
                <span class="status-value">{{ healthStatus.embedding.current_model }}</span>
              </div>
              <div class="status-line">
                <span class="status-label">Configured:</span>
                <span class="status-value">{{ getCurrentEmbeddingConfig() }}</span>
              </div>
            </div>
          </div>
          <div class="setting-item">
            <label>Embedding Provider</label>
            <select v-model="settings.backend.llm.embedding.provider" @change="onEmbeddingProviderChange">
              <option value="ollama">Ollama</option>
              <option value="openai">OpenAI</option>
            </select>
          </div>
          <div v-if="settings.backend.llm.embedding.provider === 'ollama'">
            <div class="setting-item">
              <label>Ollama Endpoint</label>
              <input type="text" v-model="settings.backend.llm.embedding.providers.ollama.endpoint" />
            </div>
            <div class="setting-item">
              <label>Embedding Model</label>
              <select v-model="settings.backend.llm.embedding.providers.ollama.selected_model" @change="notifyBackendOfEmbeddingChange">
                <option v-for="model in settings.backend.llm.embedding.providers.ollama.models" :key="model" :value="model">{{ model }}</option>
              </select>
            </div>
          </div>
          <div v-else-if="settings.backend.llm.embedding.provider === 'openai'">
            <div class="setting-item">
              <label>API Key</label>
              <input type="password" v-model="settings.backend.llm.embedding.providers.openai.api_key" placeholder="Enter API Key" />
            </div>
            <div class="setting-item">
              <label>Endpoint</label>
              <input type="text" v-model="settings.backend.llm.embedding.providers.openai.endpoint" />
            </div>
            <div class="setting-item">
              <label>Embedding Model</label>
              <select v-model="settings.backend.llm.embedding.providers.openai.selected_model" @change="notifyBackendOfEmbeddingChange">
                <option v-for="model in settings.backend.llm.embedding.providers.openai.models" :key="model" :value="model">{{ model }}</option>
              </select>
            </div>
          </div>
          <div class="settings-actions">
            <button @click="loadEmbeddingModels" aria-label="Refresh embedding models">Refresh Embedding Models</button>
          </div>
        </div>
        <div v-if="activeBackendSubTab === 'memory'" class="sub-tab-content">
          <h3>Memory Settings</h3>
          <div class="setting-item" v-if="settings.memory && settings.memory.long_term">
            <label>Enable Long-Term Memory</label>
            <input type="checkbox" v-model="settings.memory.long_term.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.long_term">
            <label>Long-Term Memory Retention (Days)</label>
            <input type="number" v-model="settings.memory.long_term.retention_days" min="1" max="365" :disabled="!settings.memory.long_term.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.short_term">
            <label>Enable Short-Term Memory</label>
            <input type="checkbox" v-model="settings.memory.short_term.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.short_term">
            <label>Short-Term Memory Duration (Minutes)</label>
            <input type="number" v-model="settings.memory.short_term.duration_minutes" min="1" max="1440" :disabled="!settings.memory.short_term.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.vector_storage">
            <label>Enable Vector Storage</label>
            <input type="checkbox" v-model="settings.memory.vector_storage.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.vector_storage">
            <label>Vector Storage Update Frequency (Days)</label>
            <input type="number" v-model="settings.memory.vector_storage.update_frequency_days" min="1" max="30" :disabled="!settings.memory.vector_storage.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.chromadb">
            <label>Enable ChromaDB</label>
            <input type="checkbox" v-model="settings.memory.chromadb.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.chromadb">
            <label>ChromaDB Path</label>
            <input type="text" v-model="settings.memory.chromadb.path" :disabled="!settings.memory.chromadb.enabled" :placeholder="getPlaceholder('memory.chromadb.path')" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.chromadb">
            <label>ChromaDB Collection Name</label>
            <input type="text" v-model="settings.memory.chromadb.collection_name" :disabled="!settings.memory.chromadb.enabled" placeholder="autobot_memory" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.redis">
            <label>Enable Redis for Chat History</label>
            <input type="checkbox" v-model="settings.memory.redis.enabled" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.redis">
            <label class="with-description">Redis Host
              <span class="description">Redis is used for storing and retrieving chat history efficiently, providing faster access compared to file-based storage.</span>
            </label>
            <input type="text" v-model="settings.memory.redis.host" :disabled="!settings.memory.redis.enabled" placeholder="localhost" />
          </div>
          <div class="setting-item" v-if="settings.memory && settings.memory.redis">
            <label>Redis Port</label>
            <input type="number" v-model="settings.memory.redis.port" min="1" max="65535" :disabled="!settings.memory.redis.enabled" :placeholder="getPlaceholder('memory.redis.port')" />
          </div>
        </div>
      </div>

      <!-- UI Settings -->
      <div v-if="activeTab === 'ui' && isSettingsLoaded" class="settings-section">
        <h3>UI Settings</h3>
        <div class="setting-item">
          <label>Theme</label>
          <select v-model="settings.ui.theme">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
          </select>
        </div>
        <div class="setting-item">
          <label>Font Size</label>
          <select v-model="settings.ui.font_size">
            <option value="small">Small</option>
            <option value="medium">Medium</option>
            <option value="large">Large</option>
          </select>
        </div>
        <div class="setting-item">
          <label>Language</label>
          <select v-model="settings.ui.language">
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
          </select>
        </div>
        <div class="setting-item">
          <label>Enable Animations</label>
          <input type="checkbox" v-model="settings.ui.animations" />
        </div>
        <div class="setting-item">
          <label>Vue Developer Mode</label>
          <input type="checkbox" v-model="settings.ui.developer_mode" />
        </div>
      </div>

      <!-- Security Settings -->
      <div v-if="activeTab === 'security' && isSettingsLoaded" class="settings-section">
        <h3>Security Settings</h3>
        <div class="setting-item">
          <label>Enable Encryption</label>
          <input type="checkbox" v-model="settings.security.enable_encryption" />
        </div>
        <div class="setting-item">
          <label>Session Timeout (Minutes)</label>
          <input type="number" v-model="settings.security.session_timeout_minutes" min="1" max="1440" />
        </div>
      </div>

      <!-- Logging Settings -->
      <div v-if="activeTab === 'logging' && isSettingsLoaded" class="settings-section">
        <h3>Logging Configuration</h3>
        
        <!-- General Logging Settings -->
        <div class="logging-section">
          <h4>General Settings</h4>
          <div class="setting-item">
            <label>Global Log Level</label>
            <select v-model="settings.logging.log_level">
              <option v-for="level in settings.logging.log_levels" :key="level" :value="level">
                {{ level.toUpperCase() }}
              </option>
            </select>
          </div>
          <div class="setting-item">
            <label>Log to File</label>
            <input type="checkbox" v-model="settings.logging.log_to_file" />
          </div>
          <div class="setting-item">
            <label>Separate Log Files by Level</label>
            <input type="checkbox" v-model="settings.logging.separate_log_files" />
          </div>
          <div class="setting-item">
            <label>Log Directory</label>
            <input type="text" v-model="settings.logging.log_directory" />
          </div>
        </div>

        <!-- Log Files Configuration -->
        <div class="logging-section" v-if="settings.logging.separate_log_files">
          <h4>System Log Files</h4>
          <div class="log-files-grid">
            <div v-for="(path, level) in settings.logging.log_files" :key="`system-${level}`" class="setting-item">
              <label>{{ level.toUpperCase() }} Log</label>
              <input type="text" v-model="settings.logging.log_files[level]" />
            </div>
          </div>
          
          <h4>Backend Log Files</h4>
          <div class="log-files-grid">
            <div v-for="(path, level) in settings.logging.backend_log_files" :key="`backend-${level}`" class="setting-item">
              <label>Backend {{ level.toUpperCase() }}</label>
              <input type="text" v-model="settings.logging.backend_log_files[level]" />
            </div>
          </div>
          
          <h4>Frontend Log Files</h4>
          <div class="log-files-grid">
            <div v-for="(path, level) in settings.logging.frontend_log_files" :key="`frontend-${level}`" class="setting-item">
              <label>Frontend {{ level.toUpperCase() }}</label>
              <input type="text" v-model="settings.logging.frontend_log_files[level]" />
            </div>
          </div>
          
          <h4>Startup Log Files</h4>
          <div class="log-files-grid">
            <div v-for="(path, level) in settings.logging.startup_log_files" :key="`startup-${level}`" class="setting-item">
              <label>Startup {{ level.toUpperCase() }}</label>
              <input type="text" v-model="settings.logging.startup_log_files[level]" />
            </div>
          </div>
        </div>

        <!-- Single Log Files (when separate_log_files is false) -->
        <div class="logging-section" v-else>
          <h4>Log File Paths</h4>
          <div class="setting-item">
            <label>Main Log File</label>
            <input type="text" v-model="settings.logging.log_file_path" />
          </div>
          <div class="setting-item">
            <label>Backend Log File</label>
            <input type="text" v-model="settings.logging.backend_log_file" />
          </div>
          <div class="setting-item">
            <label>Frontend Log File</label>
            <input type="text" v-model="settings.logging.frontend_log_file" />
          </div>
          <div class="setting-item">
            <label>Startup Log File</label>
            <input type="text" v-model="settings.logging.startup_log_file" />
          </div>
        </div>

        <!-- Log Rotation Configuration -->
        <div class="logging-section">
          <h4>Log Rotation</h4>
          <div class="setting-item">
            <label>Enable Log Rotation</label>
            <input type="checkbox" v-model="settings.logging.log_rotation.enabled" />
          </div>
          <div v-if="settings.logging.log_rotation.enabled" class="rotation-config">
            <div class="setting-item">
              <label>Rotation Type</label>
              <select v-model="settings.logging.log_rotation.rotation_type">
                <option value="size">Size-based</option>
                <option value="time">Time-based</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
              </select>
            </div>
            <div class="setting-item" v-if="settings.logging.log_rotation.rotation_type === 'size'">
              <label>Max File Size</label>
              <input type="text" v-model="settings.logging.log_rotation.max_file_size" placeholder="10MB" />
            </div>
            <div class="setting-item" v-if="settings.logging.log_rotation.rotation_type === 'time'">
              <label>Rotation Interval</label>
              <select v-model="settings.logging.log_rotation.rotation_interval">
                <option value="hourly">Hourly</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="monthly">Monthly</option>
              </select>
            </div>
            <div class="setting-item">
              <label>Max Backup Count</label>
              <input type="number" v-model="settings.logging.log_rotation.max_backup_count" min="1" max="100" />
            </div>
            <div class="setting-item">
              <label>Compress Backups</label>
              <input type="checkbox" v-model="settings.logging.log_rotation.compress_backups" />
            </div>
            <div class="setting-item">
              <label>Delete Old Logs After (days)</label>
              <input type="number" v-model="settings.logging.log_rotation.delete_old_logs_after_days" min="1" max="365" />
            </div>
            <div class="setting-item">
              <label>Rotate at Startup</label>
              <input type="checkbox" v-model="settings.logging.log_rotation.rotation_at_startup" />
            </div>
          </div>
        </div>

        <!-- Startup Log Rotation -->
        <div class="logging-section">
          <h4>Startup Log Rotation</h4>
          <div class="setting-item">
            <label>Enable Startup Log Rotation</label>
            <input type="checkbox" v-model="settings.logging.startup_log_rotation.enabled" />
          </div>
          <div v-if="settings.logging.startup_log_rotation.enabled" class="startup-rotation-config">
            <div class="setting-item">
              <label>Rotate on Every Startup</label>
              <input type="checkbox" v-model="settings.logging.startup_log_rotation.rotate_on_startup" />
            </div>
            <div class="setting-item">
              <label>Max Backup Count</label>
              <input type="number" v-model="settings.logging.startup_log_rotation.max_backup_count" min="1" max="50" />
            </div>
            <div class="setting-item">
              <label>Compress Backups</label>
              <input type="checkbox" v-model="settings.logging.startup_log_rotation.compress_backups" />
            </div>
            <div class="setting-item">
              <label>Delete Old Logs After (days)</label>
              <input type="number" v-model="settings.logging.startup_log_rotation.delete_old_logs_after_days" min="1" max="365" />
            </div>
            <div class="setting-item">
              <label>Backup Naming</label>
              <select v-model="settings.logging.startup_log_rotation.backup_naming">
                <option value="timestamp">Timestamp</option>
                <option value="sequential">Sequential</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Log File Size Limits -->
        <div class="logging-section">
          <h4>Size Limits</h4>
          <div class="setting-item">
            <label>Max Log Size (MB)</label>
            <input type="number" v-model="settings.logging.max_log_size_mb" min="1" max="1000" />
          </div>
          <div class="setting-item">
            <label>Backup Count</label>
            <input type="number" v-model="settings.logging.backup_count" min="1" max="50" />
          </div>
        </div>
      </div>

      <!-- Cache Management Settings -->
      <div v-if="activeTab === 'cache' && isSettingsLoaded" class="settings-section">
        <h3>Cache Management</h3>
        
        <!-- Cache Statistics -->
        <div class="cache-stats">
          <h4>Cache Statistics</h4>
          <div v-if="cacheStats" class="stats-grid">
            <div class="stat-item">
              <label>Frontend Cache Entries</label>
              <span>{{ cacheStats.frontend?.totalEntries || 0 }}</span>
            </div>
            <div class="stat-item">
              <label>Valid Entries</label>
              <span>{{ cacheStats.frontend?.validEntries || 0 }}</span>
            </div>
            <div class="stat-item">
              <label>Expired Entries</label>
              <span>{{ cacheStats.frontend?.expiredEntries || 0 }}</span>
            </div>
            <div class="stat-item">
              <label>Estimated Size</label>
              <span>{{ formatBytes(cacheStats.frontend?.estimatedSizeBytes || 0) }}</span>
            </div>
          </div>
          <button @click="refreshCacheStats" class="refresh-btn">
            <i class="fas fa-sync-alt"></i> Refresh Stats
          </button>
        </div>

        <!-- Clear Cache Options -->
        <div class="cache-actions">
          <h4>Clear Cache Options</h4>
          
          <div class="cache-action-group">
            <h5>Frontend Cache</h5>
            <div class="cache-info">
              <div class="cache-size-info">
                <span class="cache-label">Total Size:</span>
                <span class="cache-size">{{ formatBytes(cacheStats?.frontend?.estimatedSizeBytes || 0) }}</span>
                <span class="cache-label">Entries:</span>
                <span class="cache-entries">{{ cacheStats?.frontend?.totalEntries || 0 }}</span>
              </div>
            </div>
            <div class="action-buttons">
              <button @click="clearFrontendCache" class="clear-btn" :disabled="isClearing">
                <i class="fas fa-trash-alt"></i> Clear Frontend Cache
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearFrontendCacheCategory('settings')" class="clear-btn category-btn" :disabled="isClearing">
                <i class="fas fa-cog"></i> Clear Settings Cache
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearFrontendCacheCategory('chats')" class="clear-btn category-btn" :disabled="isClearing">
                <i class="fas fa-comments"></i> Clear Chat Cache
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
            </div>
          </div>

          <div class="cache-action-group">
            <h5>Backend Cache</h5>
            <div class="cache-info">
              <div class="cache-size-info">
                <span class="cache-label">Backend Status:</span>
                <span class="cache-status" :class="{ 'online': cacheStats?.backend, 'offline': !cacheStats?.backend }">
                  {{ cacheStats?.backend ? 'Online' : 'Offline' }}
                </span>
                <span v-if="cacheStats?.backend?.total_memory" class="cache-label">Memory:</span>
                <span v-if="cacheStats?.backend?.total_memory" class="cache-size">{{ formatBytes(cacheStats.backend.total_memory) }}</span>
              </div>
            </div>
            <div class="action-buttons">
              <button @click="clearBackendCache" class="clear-btn" :disabled="isClearing">
                <i class="fas fa-server"></i> Clear Backend Configuration Cache
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearBackendCache('llm')" class="clear-btn category-btn" :disabled="isClearing">
                <i class="fas fa-brain"></i> Clear LLM Cache
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
            </div>
          </div>

          <div class="cache-action-group">
            <h5>Browser Storage</h5>
            <div class="cache-info">
              <div class="cache-size-info">
                <span class="cache-label">LocalStorage Items:</span>
                <span class="cache-entries">{{ Object.keys(localStorage).length }}</span>
                <span class="cache-label">SessionStorage Items:</span>
                <span class="cache-entries">{{ Object.keys(sessionStorage).length }}</span>
              </div>
            </div>
            <div class="action-buttons">
              <button @click="clearLocalStorage" class="clear-btn" :disabled="isClearing">
                <i class="fas fa-database"></i> Clear Local Storage
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearSessionStorage" class="clear-btn" :disabled="isClearing">
                <i class="fas fa-clock"></i> Clear Session Storage
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
            </div>
          </div>

          <div class="cache-action-group">
            <h5>Redis Cache</h5>
            <div class="cache-info">
              <div class="cache-size-info">
                <span class="cache-label">Redis Status:</span>
                <span class="cache-status" :class="{ 'online': cacheStats?.backend?.redis_connected, 'offline': !cacheStats?.backend?.redis_connected }">
                  {{ cacheStats?.backend?.redis_connected ? 'Connected' : 'Disconnected' }}
                </span>
                <span v-if="cacheStats?.backend?.redis_databases" class="cache-label">Databases:</span>
                <span v-if="cacheStats?.backend?.redis_databases" class="cache-entries">{{ Object.keys(cacheStats.backend.redis_databases || {}).length }}</span>
              </div>
            </div>
            <div class="action-buttons">
              <button @click="clearRedisCache('all')" class="clear-btn danger" :disabled="isClearing">
                <i class="fas fa-exclamation-triangle"></i> Clear All Redis Databases
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearRedisCache('main')" class="clear-btn category-btn" :disabled="isClearing">
                <i class="fas fa-home"></i> Clear Main DB (0)
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearRedisCache('knowledge')" class="clear-btn category-btn" :disabled="isClearing">
                <i class="fas fa-book"></i> Clear Knowledge DB (1)
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
              <button @click="clearRedisCache('prompts')" class="clear-btn category-btn" :disabled="isClearing">
                <i class="fas fa-file-alt"></i> Clear Prompts DB (2)
                <span v-if="isClearing" class="loading-dots">...</span>
              </button>
            </div>
          </div>

          <div class="cache-action-group">
            <h5>Complete System Reset</h5>
            <div class="action-buttons">
              <button @click="clearAllCaches" class="clear-btn danger-full" :disabled="isClearing">
                <i class="fas fa-bomb"></i> Clear ALL Caches (System Reset)
              </button>
            </div>
          </div>
        </div>

        <!-- Cache Configuration -->
        <div class="cache-config">
          <h4>Cache Configuration</h4>
          
          <div class="setting-item">
            <label>Default Cache TTL (minutes)</label>
            <input type="number" v-model="cacheConfig.defaultTTLMinutes" min="1" max="1440" />
          </div>
          
          <div class="setting-item">
            <label>Settings Cache TTL (minutes)</label>
            <input type="number" v-model="cacheConfig.settingsTTLMinutes" min="1" max="1440" />
          </div>
          
          <div class="setting-item">
            <label>Auto Cleanup Enabled</label>
            <input type="checkbox" v-model="cacheConfig.autoCleanupEnabled" />
          </div>
          
          <div class="setting-item">
            <label>Max Cache Size (MB)</label>
            <input type="number" v-model="cacheConfig.maxCacheSizeMB" min="10" max="1000" />
          </div>
          
          <button @click="saveCacheConfig" class="save-btn" :disabled="isSaving">
            <i class="fas fa-save"></i> Save Cache Configuration
          </button>
        </div>

        <!-- Cache Activity Log -->
        <div v-if="cacheActivityLog.length > 0" class="cache-activity">
          <h4>Recent Cache Activity</h4>
          <div class="activity-log">
            <div v-for="activity in cacheActivityLog" :key="activity.id" class="activity-item">
              <span class="timestamp">{{ formatTime(activity.timestamp) }}</span>
              <span class="action" :class="activity.type">{{ activity.message }}</span>
            </div>
          </div>
          <button @click="clearActivityLog" class="clear-log-btn">
            <i class="fas fa-eraser"></i> Clear Activity Log
          </button>
        </div>
      </div>

      <!-- Voice Interface Settings -->
      <div v-if="activeTab === 'voiceInterface' && isSettingsLoaded" class="settings-section">
        <h3>Voice Interface</h3>
        <div class="setting-item">
          <label>Enable Voice Interface</label>
          <input type="checkbox" v-model="settings.voice_interface.enabled" />
        </div>
        <div class="setting-item">
          <label>Voice</label>
          <select v-model="settings.voice_interface.voice" :disabled="!settings.voice_interface.enabled">
            <option value="default">Default</option>
            <option value="male1">Male 1</option>
            <option value="female1">Female 1</option>
          </select>
        </div>
        <div class="setting-item">
          <label>Speech Rate</label>
          <input type="number" v-model="settings.voice_interface.speech_rate" min="0.5" max="2.0" step="0.1" :disabled="!settings.voice_interface.enabled" />
        </div>
      </div>

      <!-- Developer Settings -->
      <div v-if="activeTab === 'developer' && isSettingsLoaded" class="settings-section">
        <h3>Developer Mode</h3>
        <div class="setting-item">
          <label>Enable Developer Mode</label>
          <input type="checkbox" v-model="settings.developer.enabled" @change="updateDeveloperConfig" />
        </div>
        <div v-if="settings.developer.enabled">
          <div class="setting-item">
            <label>Enhanced Error Messages</label>
            <input type="checkbox" v-model="settings.developer.enhanced_errors" @change="updateDeveloperConfig" />
          </div>
          <div class="setting-item">
            <label>API Endpoint Suggestions</label>
            <input type="checkbox" v-model="settings.developer.endpoint_suggestions" @change="updateDeveloperConfig" />
          </div>
          <div class="setting-item">
            <label>Debug Logging</label>
            <input type="checkbox" v-model="settings.developer.debug_logging" @change="updateDeveloperConfig" />
          </div>
          
          <!-- RUM (Real User Monitoring) Settings -->
          <div class="rum-settings">
            <h4>Real User Monitoring (RUM)</h4>
            <div class="setting-item">
              <label class="with-description">
                Enable RUM Agent
                <span class="description">Monitor user interactions, performance metrics, and errors in real-time</span>
              </label>
              <input type="checkbox" v-model="settings.developer.rum.enabled" @change="updateRumConfig" />
            </div>
            <div class="rum-config" v-if="settings.developer?.rum?.enabled === true">
              <div class="setting-item">
                <label class="with-description">
                  Error Tracking
                  <span class="description">Capture JavaScript errors and exceptions</span>
                </label>
                <input type="checkbox" v-model="settings.developer.rum.error_tracking" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label class="with-description">
                  Performance Monitoring
                  <span class="description">Track page load times, API calls, and resource loading</span>
                </label>
                <input type="checkbox" v-model="settings.developer.rum.performance_monitoring" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label class="with-description">
                  User Interaction Tracking
                  <span class="description">Monitor clicks, form submissions, and navigation</span>
                </label>
                <input type="checkbox" v-model="settings.developer.rum.interaction_tracking" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label class="with-description">
                  Session Recording
                  <span class="description">Record user sessions for debugging (privacy-aware)</span>
                </label>
                <input type="checkbox" v-model="settings.developer.rum.session_recording" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label>Sample Rate (%)</label>
                <input type="number" v-model="settings.developer.rum.sample_rate" 
                       min="0" max="100" step="1" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label>Max Events per Session</label>
                <input type="number" v-model="settings.developer.rum.max_events_per_session" 
                       min="100" max="10000" step="100" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label class="with-description">
                  Debug Mode
                  <span class="description">Enable console logging for RUM events</span>
                </label>
                <input type="checkbox" v-model="settings.developer.rum.debug_mode" @change="updateRumConfig" />
              </div>
              <div class="setting-item">
                <label class="with-description">
                  RUM Log Level
                  <span class="description">Control verbosity of RUM backend logging</span>
                </label>
                <select v-model="settings.developer.rum.log_level" @change="updateRumConfig">
                  <option v-for="level in settings.logging.log_levels" :key="level" :value="level">
                    {{ level.toUpperCase() }}
                  </option>
                </select>
              </div>
              
              <!-- RUM Status Display -->
              <div class="rum-status" v-if="settings.developer?.rum?.enabled && rumStatus && rumStatus.active">
                <h5>RUM Agent Status</h5>
                <div class="status-grid">
                  <div class="status-item">
                    <label>Agent Status</label>
                    <span :class="['status-value', rumStatus.active ? 'active' : 'inactive']">
                      {{ rumStatus.active ? 'Active' : 'Inactive' }}
                    </span>
                  </div>
                  <div class="status-item">
                    <label>Events Collected</label>
                    <span class="status-value">{{ rumStatus.events_count || 0 }}</span>
                  </div>
                  <div class="status-item">
                    <label>Session Duration</label>
                    <span class="status-value">{{ formatDuration(rumStatus.session_duration) }}</span>
                  </div>
                  <div class="status-item">
                    <label>Last Event</label>
                    <span class="status-value">{{ formatTime(rumStatus.last_event_time) }}</span>
                  </div>
                </div>
                
                <div class="rum-actions">
                  <button @click="refreshRumStatus" class="refresh-btn">
                    <i class="fas fa-sync-alt"></i> Refresh Status
                  </button>
                  <button @click="clearRumData" class="clear-btn category-btn">
                    <i class="fas fa-trash-alt"></i> Clear RUM Data
                  </button>
                  <button @click="exportRumData" class="export-btn">
                    <i class="fas fa-download"></i> Export Data
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <div class="developer-info" v-if="developerInfo">
            <h4>System Information</h4>
            <div class="info-item">
              <strong>Available API Endpoints:</strong> {{ developerInfo.total_endpoints || 0 }}
            </div>
            <div class="info-item">
              <strong>Active Routers:</strong> {{ (developerInfo.available_routers || []).join(', ') }}
            </div>
            <div class="settings-actions">
              <button @click="loadDeveloperInfo" aria-label="Refresh system info">Refresh System Info</button>
              <button @click="showApiEndpoints" aria-label="View api endpoints">View API Endpoints</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Agent Settings -->
      <div v-if="activeTab === 'agents' && isSettingsLoaded" class="settings-section">
        <h3>AI Agent Configuration</h3>
        <div class="agents-overview" v-if="agentsList">
          <div class="agents-summary">
            <div class="summary-item">
              <span class="summary-label">Total Agents:</span>
              <span class="summary-value">{{ agentsList.total_count || 0 }}</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Enabled:</span>
              <span class="summary-value">{{ enabledAgentsCount }}</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Health Status:</span>
              <span :class="['summary-value', getOverallHealthClass()]">{{ getOverallHealthStatus() }}</span>
            </div>
          </div>
          <div class="agents-list">
            <div v-for="agent in agentsList.agents" :key="agent.id" class="agent-card">
              <div class="agent-header">
                <h4>{{ agent.name }}</h4>
                <div class="agent-controls">
                  <label class="toggle-switch">
                    <input type="checkbox" :checked="agent.enabled" @change="toggleAgent(agent.id, $event.target.checked)" />
                    <span class="toggle-slider"></span>
                  </label>
                  <span :class="['agent-status', agent.status]">{{ agent.status }}</span>
                </div>
              </div>
              <p class="agent-description">{{ agent.description }}</p>
              <div class="agent-config">
                <div class="config-item">
                  <label>Model:</label>
                  <select v-model="agent.current_model" @change="updateAgentModel(agent.id, agent.current_model)" :disabled="!agent.enabled">
                    <option v-for="model in availableModels" :key="model" :value="model">{{ model }}</option>
                  </select>
                </div>
                <div class="config-item">
                  <label>Provider:</label>
                  <select v-model="agent.provider" @change="updateAgentProvider(agent.id, agent.provider)" :disabled="!agent.enabled">
                    <option value="ollama">Ollama</option>
                    <option value="openai">OpenAI</option>
                    <option value="anthropic">Anthropic</option>
                  </select>
                </div>
                <div class="config-item">
                  <label>Priority:</label>
                  <input type="number" v-model="agent.priority" @change="updateAgentPriority(agent.id, agent.priority)" min="1" max="10" :disabled="!agent.enabled" />
                </div>
              </div>
              <div class="agent-tasks" v-if="agent.tasks && agent.tasks.length > 0">
                <span class="tasks-label">Tasks:</span>
                <div class="tasks-tags">
                  <span v-for="task in agent.tasks" :key="task" class="task-tag">{{ task }}</span>
                </div>
              </div>
              <div class="agent-performance" v-if="agent.performance">
                <div class="performance-item">
                  <span class="perf-label">Success Rate:</span>
                  <span class="perf-value">{{ (agent.performance.success_rate * 100).toFixed(1) }}%</span>
                </div>
                <div class="performance-item">
                  <span class="perf-label">Avg Response:</span>
                  <span class="perf-value">{{ agent.performance.avg_response_time ? agent.performance.avg_response_time.toFixed(2) + 's' : 'N/A' }}</span>
                </div>
                <div class="performance-item">
                  <span class="perf-label">Total Requests:</span>
                  <span class="perf-value">{{ agent.performance.total_requests || 0 }}</span>
                </div>
              </div>
            </div>
          </div>
          <div class="agents-actions">
            <button @click="refreshAgents" class="refresh-button">Refresh Agent Status</button>
            <button @click="testAllAgents" class="test-button">Test All Agents</button>
          </div>
        </div>
        <div v-else class="agents-loading">
          <div class="loading-spinner"></div>
          <p>Loading agent configurations...</p>
        </div>
      </div>

      <!-- System Prompts Settings -->
      <div v-if="activeTab === 'prompts' && isSettingsLoaded" class="settings-section">
        <h3>System Prompts</h3>
        <div class="prompts-container">
          <div class="prompts-list">
            <div v-for="prompt in settings.prompts.list" :key="prompt.id" class="prompt-item" :class="{ 'active': settings.prompts.selectedPrompt && settings.prompts.selectedPrompt.id === prompt.id }" @click="selectPrompt(prompt)" tabindex="0" @keyup.enter="$event.target.click()" @keyup.space="$event.target.click()">
              <div class="prompt-name">{{ prompt.name || prompt.id }}</div>
              <div class="prompt-type">{{ prompt.type || 'Unknown Type' }}</div>
            </div>
            <div v-if="settings.prompts.list.length === 0" class="no-prompts">No prompts available. Please check backend connection.</div>
          </div>
          <div class="prompt-editor" v-if="settings.prompts.selectedPrompt">
            <h4>Editing: {{ settings.prompts.selectedPrompt.name || settings.prompts.selectedPrompt.id }}</h4>
            <textarea v-model="settings.prompts.editedContent" rows="10" placeholder="Edit prompt content here..."></textarea>
            <div class="editor-actions">
              <button @click="savePrompt" aria-label="Save changes">Save Changes</button>
              <button @click="revertPromptToDefault(settings.prompts.selectedPrompt.id)" aria-label="Revert to default">Revert to Default</button>
              <button @click="settings.prompts.selectedPrompt = null" aria-label="Cancel">Cancel</button>
            </div>
          </div>
        </div>
        <div class="setting-item">
          <button class="control-button small" @click="loadPrompts" aria-label="Load prompts">Load Prompts</button>
        </div>
      </div>
    </div>
    <div class="settings-actions">
      <button @click="saveSettings" :disabled="isSaving" class="save-button" :aria-label="isSaving ? 'Saving...' : 'Save Settings'">
        {{ isSaving ? 'Saving...' : 'Save Settings' }}
      </button>
      <div v-if="saveMessage" :class="['save-message', saveMessageType]">
        {{ saveMessage }}
      </div>
    </div>
    </div>
  </ErrorBoundary>
</template>

<script>
import { ref, onMounted, watch, computed, onUnmounted } from 'vue';
import apiClient from '../utils/ApiClient.js';
import { settingsService } from '../services/SettingsService.js';
import { healthService } from '../services/HealthService.js';
import cacheService from '../services/CacheService.js';
import ErrorBoundary from './ErrorBoundary.vue';
import { API_CONFIG } from '@/config/environment.js';

export default {
  name: 'SettingsPanel',
  components: {
    ErrorBoundary
  },
  setup() {
    // Define tabs for settings organization
    const tabs = [
      { id: 'chat', label: 'Chat' },
      { id: 'backend', label: 'Backend' },
      { id: 'agents', label: 'Agents' },
      { id: 'ui', label: 'UI' },
      { id: 'security', label: 'Security' },
      { id: 'logging', label: 'Logging' },
      { id: 'cache', label: 'Cache' },
      { id: 'voiceInterface', label: 'Voice Interface' },
      { id: 'prompts', label: 'System Prompts' },
      { id: 'developer', label: 'Developer' }
    ];
    const activeTab = ref('backend');
    const activeBackendSubTab = ref('memory');

    // Empty settings structure - all values MUST come from backend configuration
    // NO HARDCODED DEFAULTS ALLOWED - see DEVELOPMENT_STANDARDS.md
    const createEmptySettings = () => ({
      message_display: {},
      chat: {},
      backend: {
        api_endpoint: API_CONFIG.BASE_URL, // Only bootstrap URL allowed
        llm: {
          provider_type: null,
          local: { provider: null, providers: {} },
          cloud: { provider: null, providers: {} },
          embedding: { provider: null, providers: {} }
        }
      },
      ui: {},
      security: {},
      logging: {
        log_level: 'info',
        log_levels: ['debug', 'info', 'warning', 'error', 'critical'],
        log_to_file: true,
        separate_log_files: true,
        log_file_path: 'logs/system.log',
        log_directory: 'logs',
        log_files: {
          debug: 'logs/system.debug.log',
          info: 'logs/system.info.log',
          warning: 'logs/system.warning.log',
          error: 'logs/system.error.log',
          critical: 'logs/system.critical.log'
        },
        backend_log_file: 'logs/backend.log',
        backend_log_files: {
          debug: 'logs/backend.debug.log',
          info: 'logs/backend.info.log',
          warning: 'logs/backend.warning.log',
          error: 'logs/backend.error.log',
          critical: 'logs/backend.critical.log'
        },
        frontend_log_file: 'logs/frontend.log',
        frontend_log_files: {
          debug: 'logs/frontend.debug.log',
          info: 'logs/frontend.info.log',
          warning: 'logs/frontend.warning.log',
          error: 'logs/frontend.error.log',
          critical: 'logs/frontend.critical.log'
        },
        startup_log_file: 'logs/startup.log',
        startup_log_files: {
          debug: 'logs/startup.debug.log',
          info: 'logs/startup.info.log',
          warning: 'logs/startup.warning.log',
          error: 'logs/startup.error.log',
          critical: 'logs/startup.critical.log'
        },
        backup_count: 5,
        max_log_size_mb: 10,
        log_rotation: {
          enabled: true,
          rotation_type: 'size',
          max_file_size: '10MB',
          max_backup_count: 7,
          rotation_interval: 'daily',
          compress_backups: true,
          delete_old_logs_after_days: 30,
          rotation_at_startup: false
        },
        startup_log_rotation: {
          enabled: true,
          rotate_on_startup: true,
          max_backup_count: 10,
          compress_backups: true,
          delete_old_logs_after_days: 90,
          backup_naming: 'timestamp'
        }
      },
      knowledge_base: {},
      voice_interface: {
        enabled: false,
        voice: 'default',
        speech_rate: 1.0
      },
      memory: {
        long_term: {
          enabled: false,
          retention_days: 30
        },
        short_term: {
          enabled: false,
          duration_minutes: 60
        },
        vector_storage: {
          enabled: false,
          update_frequency_days: 7
        },
        chromadb: {
          enabled: false,
          path: './data/chromadb',
          collection_name: 'autobot_memory'
        },
        redis: {
          enabled: false,
          host: 'localhost',
          port: 6379
        }
      },
      prompts: {
        list: [],
        selectedPrompt: null,
        editedContent: '',
        defaults: {}
      },
      developer: {
        enabled: false,
        enhanced_errors: true,
        endpoint_suggestions: true,
        debug_logging: false,
        rum: {
          enabled: false,
          error_tracking: true,
          performance_monitoring: true,
          interaction_tracking: false,
          session_recording: false,
          sample_rate: 100,
          max_events_per_session: 1000,
          debug_mode: false,
          log_to_backend: true,
          log_level: 'info'
        }
      }
    });

    // Settings structure will be populated from backend or local storage
    const settings = ref(createEmptySettings());
    const isSettingsLoaded = ref(false);
    const settingsLoadingStatus = ref('loading'); // 'loading', 'loaded', 'error', 'offline'
    const developerInfo = ref(null);
    const healthStatus = ref({
      llm: {
        connected: false,
        current_model: null
      },
      embedding: {
        connected: false,
        current_model: null
      }
    });
    
    // Agent management state
    const agentsList = ref(null);
    const availableModels = ref([]);

    // Save state management
    const isSaving = ref(false);
    const saveMessage = ref('');
    const saveMessageType = ref(''); // 'success' or 'error'

    // Cache management state
    const cacheStats = ref(null);
    const isClearing = ref(false);
    const cacheActivityLog = ref([]);
    const cacheConfig = ref({
      defaultTTLMinutes: 5,
      settingsTTLMinutes: 10,
      autoCleanupEnabled: true,
      maxCacheSizeMB: 100
    });

    // RUM (Real User Monitoring) state
    const rumStatus = ref(null);

    // Computed property for CORS origins as a string for input field
    const corsOriginsString = computed({
      get() {
        return settings.value.backend.cors_origins.join(', ');
      },
      set(value) {
        settings.value.backend.cors_origins = value.split(',').map(origin => origin.trim()).filter(origin => origin);
      }
    });

    // Function to check health status
    const checkHealthStatus = async () => {
      try {
        const data = await apiClient.checkHealth();
        healthStatus.value = {
          llm: {
            connected: data.llm_status || false,
            current_model: data.current_model || null
          },
          embedding: {
            connected: data.embedding_status || false,
            current_model: data.current_embedding_model || null
          }
        };
      } catch (error) {
        console.error('Error checking health status:', error);
      }
    };

    let healthCheckInterval;
    let agentConfigSyncInterval;

    onMounted(async () => {
      // Load settings from backend
      await loadSettingsFromBackend();
      isSettingsLoaded.value = true;
      // Load models after settings are loaded
      await loadModels();
      await loadEmbeddingModels();
      // Load agent configurations
      await loadAgents();
      // Check health status
      await checkHealthStatus();
      // Set up periodic health checks
      healthCheckInterval = setInterval(checkHealthStatus, 10000); // Check every 10 seconds
      // Set up periodic agent config sync to ensure settings always match actual status
      agentConfigSyncInterval = setInterval(syncSettingsWithAgentConfig, 15000); // Sync every 15 seconds
    });

    onUnmounted(() => {
      if (healthCheckInterval) {
        clearInterval(healthCheckInterval);
      }
      if (agentConfigSyncInterval) {
        clearInterval(agentConfigSyncInterval);
      }
    });

    // Function to deep merge objects
    const deepMerge = (target, source) => {
      const output = { ...target };
      for (const key in source) {
        if (source.hasOwnProperty(key)) {
          if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key])) {
            output[key] = deepMerge(target[key] || {}, source[key]);
          } else {
            output[key] = source[key];
          }
        }
      }
      return output;
    };

    // Function to load settings from backend config.yaml
    const loadSettingsFromBackend = async () => {
      let settingsSource = 'default';

      try {
        const response = await apiClient.get('/api/settings/config');
        const configSettings = await response.json();
        settings.value = deepMerge(createEmptySettings(), configSettings);

        // SYNC WITH AGENT CONFIG: Ensure settings match actual agent status
        await syncSettingsWithAgentConfig();

        // Save to local storage as well
        localStorage.setItem('chat_settings', JSON.stringify(settings.value));
        settingsSource = 'backend';
        settingsLoadingStatus.value = 'loaded';

        // Clear any previous error messages
        if (saveMessage.value && saveMessage.value.includes('backend offline')) {
          saveMessage.value = '';
        }

      } catch (error) {
        console.warn('Backend unavailable, using local settings:', error.message);

        // Load from local storage if backend fails
        const savedSettings = localStorage.getItem('chat_settings');
        if (savedSettings) {
          try {
            const parsedSettings = JSON.parse(savedSettings);
            settings.value = deepMerge(createEmptySettings(), parsedSettings);
            settingsSource = 'local';
          } catch (e) {
            console.error('Error parsing saved settings:', e);
            settings.value = createEmptySettings();
            settingsSource = 'default';
          }
        } else {
          settings.value = createEmptySettings();
          settingsSource = 'default';
        }

        // Show user-friendly message about offline mode
        saveMessage.value = `Settings loaded from ${settingsSource} storage (backend offline)`;
        saveMessageType.value = 'warning';
        settingsLoadingStatus.value = 'offline';
      }

      // Load prompts after settings are loaded
      await loadPrompts();

      // Mark settings as loaded regardless of source
      isSettingsLoaded.value = true;

      console.info(`Settings loaded from: ${settingsSource}`);
    };

    // Function to sync settings panel with actual agent configuration
    const syncSettingsWithAgentConfig = async () => {
      try {
        // Get comprehensive LLM status to see what's actually configured
        const llmStatusResponse = await apiClient.get('/api/llm/status/comprehensive');
        const llmStatus = await llmStatusResponse.json();

        // Get agent configuration to see actual agent models
        const agentConfigResponse = await apiClient.get('/api/agent-config/agents');
        const agentConfig = await agentConfigResponse.json();

        // Syncing settings with agent config

        // Update settings to match actual LLM status
        if (llmStatus && settings.value.backend && settings.value.backend.llm) {
          // Sync provider type
          settings.value.backend.llm.provider_type = llmStatus.provider_type || 'local';

          // Sync active provider info
          if (llmStatus.active_provider) {
            const activeProvider = llmStatus.active_provider;

            if (activeProvider.type === 'local') {
              settings.value.backend.llm.local.provider = activeProvider.name || 'ollama';
              if (activeProvider.model && settings.value.backend.llm.local.providers[activeProvider.name]) {
                settings.value.backend.llm.local.providers[activeProvider.name].selected_model = activeProvider.model;
              }
            } else if (activeProvider.type === 'cloud') {
              settings.value.backend.llm.cloud.provider = activeProvider.name || 'openai';
              if (activeProvider.model && settings.value.backend.llm.cloud.providers[activeProvider.name]) {
                settings.value.backend.llm.cloud.providers[activeProvider.name].selected_model = activeProvider.model;
              }
            }
          }

          // Sync streaming setting
          if (llmStatus.settings) {
            settings.value.backend.streaming = llmStatus.settings.streaming || false;
            settings.value.backend.timeout = llmStatus.settings.timeout || 60;
            settings.value.backend.max_retries = llmStatus.settings.max_retries || 3;
          }
        }

        // Log the sync result for debugging
        // Settings synced with agent config

      } catch (error) {
        console.error('Error syncing settings with agent config:', error);

        // Show user-friendly error message for settings sync failure
        let errorMessage = 'Settings sync partially failed';
        if (error.message?.includes('500')) {
          errorMessage = ' LLM status endpoint unavailable - some settings may not reflect current state';
        } else if (error.message?.includes('timeout')) {
          errorMessage = ' Settings sync timeout - using cached configuration';
        } else if (error.message?.includes('Network') || error.message?.includes('fetch')) {
          errorMessage = ' Network error during settings sync - using offline mode';
        }

        // Set save message to show the error
        saveMessage.value = errorMessage;
        saveMessageType.value = 'warning';

        // Auto-hide the warning after 5 seconds
        setTimeout(() => {
          if (saveMessageType.value === 'warning') {
            saveMessage.value = '';
            saveMessageType.value = '';
          }
        }, 5000);

        // Don't fail the settings load if sync fails
      }
    };

    /**
     * Get placeholder text from configuration, not hardcoded values
     * This ensures no hardcoded configuration values per DEVELOPMENT_STANDARDS.md
     * @param {string} path - The configuration path (e.g., 'memory.redis.port')
     * @returns {string} - The placeholder text from configuration or empty string
     */
    const getPlaceholder = (path) => {
      // Get placeholder from loaded configuration
      // NEVER return hardcoded values here
      if (!settings.value || !settings.value.ui) return '';
      
      const placeholders = settings.value.ui.placeholders || {};
      return placeholders[path] || '';
    };

    // Function to save settings to config.yaml via backend
    const saveSettings = async () => {
      isSaving.value = true;
      saveMessage.value = '';
      saveMessageType.value = '';

      try {
        // FIRST: Save developer settings separately to preserve RUM config
        if (settings.value.developer) {
          try {
            await settingsService.updateDeveloperConfig(settings.value.developer);
            console.log('Developer config saved successfully');
          } catch (devError) {
            console.warn('Could not save developer config:', devError);
          }
        }
        
        // Create a deep copy of settings without prompts data (prompts shouldn't be saved to config.yaml)
        const settingsToSave = JSON.parse(JSON.stringify(settings.value));
        delete settingsToSave.prompts;

        const response = await apiClient.post('/api/settings/config', settingsToSave);
        const result = await response.json();

        // Clear frontend cache to ensure fresh data
        cacheService.invalidateCategory('settings');
        
        // Clear backend cache as well
        try {
          await apiClient.post('/api/settings/clear-cache');
        } catch (error) {
          console.warn('Could not clear backend cache:', error);
        }

        // Force a complete reload of settings from backend
        await forceReloadSettings();

        // Show success message
        saveMessage.value = 'Settings saved successfully!';
        saveMessageType.value = 'success';

        // Clear message after 3 seconds
        setTimeout(() => {
          saveMessage.value = '';
          saveMessageType.value = '';
        }, 3000);
      } catch (error) {
        console.error('Error saving settings to backend:', error);
        saveMessage.value = `Error saving settings: ${error.message}`;
        saveMessageType.value = 'error';

        // Clear error message after 5 seconds
        setTimeout(() => {
          saveMessage.value = '';
          saveMessageType.value = '';
        }, 5000);
      } finally {
        isSaving.value = false;
      }
    };

    // Watch for changes in settings and save them to local storage only
    // Don't auto-save to backend - only save to localStorage for persistence
    watch(settings, () => {
      if (isSettingsLoaded.value) {
        localStorage.setItem('chat_settings', JSON.stringify(settings.value));
      }
    }, { deep: true });

    // Function to load prompts from backend
    const loadPrompts = async () => {
      try {
        const promptsData = await apiClient.getPrompts();
        settings.value.prompts.list = promptsData.prompts || [];
        settings.value.prompts.defaults = promptsData.defaults || {};
      } catch (error) {
        console.error('Error loading prompts from backend:', error);
      }
    };

    // Function to select a prompt for editing
    const selectPrompt = (prompt) => {
      settings.value.prompts.selectedPrompt = prompt;
      settings.value.prompts.editedContent = prompt.content || '';
    };

    // Function to save edited prompt content
    const savePrompt = async () => {
      if (!settings.value.prompts.selectedPrompt) return;
      try {
        const promptId = settings.value.prompts.selectedPrompt.id;
        const updatedPrompt = await apiClient.savePrompt(promptId, settings.value.prompts.editedContent);
        const index = settings.value.prompts.list.findIndex(p => p.id === promptId);
        if (index !== -1) {
          settings.value.prompts.list[index] = updatedPrompt;
        }
        // Clear selection
        settings.value.prompts.selectedPrompt = null;
        settings.value.prompts.editedContent = '';
      } catch (error) {
        console.error('Error saving prompt to backend:', error);
      }
    };

    // Function to dynamically load models from the selected provider
    const loadModels = async () => {
      try {
        const data = await apiClient.loadLlmModels();

        if (settings.value.backend.llm.provider_type === 'local') {
          const provider = settings.value.backend.llm.local.provider;

          if (provider === 'ollama') {
            // Handle the new API response format with model objects
            let availableModels = [];

            // Try different response structures
            if (data.models && Array.isArray(data.models)) {
              // If models have a structure with 'available' and 'type' fields
              if (data.models.length > 0 && typeof data.models[0] === 'object') {
                availableModels = data.models
                  .filter(model => {
                    // Include models that are available and either have no type or are ollama type
                    return model.available !== false && (!model.type || model.type === 'ollama');
                  })
                  .map(model => model.name || model.id || model);
              } else {
                // If models are just strings
                availableModels = data.models;
              }
            } else if (Array.isArray(data)) {
              // If the response is directly an array
              availableModels = data.map(model =>
                typeof model === 'string' ? model : (model.name || model.id || model)
              );
            }

            settings.value.backend.llm.local.providers.ollama.models = availableModels;

            if (availableModels.length === 0) {
              console.warn('No Ollama models found. Raw API response:', data);
              // Try to provide helpful feedback
              if (data.error) {
                console.error('API Error:', data.error);
              }
            }

            // Auto-select first model if none selected
            if (!settings.value.backend.llm.local.providers.ollama.selected_model && availableModels.length > 0) {
              settings.value.backend.llm.local.providers.ollama.selected_model = availableModels[0];
            }

            // Validate current selection is still available
            const currentModel = settings.value.backend.llm.local.providers.ollama.selected_model;
            if (currentModel && !availableModels.includes(currentModel)) {
              settings.value.backend.llm.local.providers.ollama.selected_model = availableModels[0] || '';
            }

          } else if (provider === 'lmstudio') {
            // Handle LM Studio models - try different response formats
            let lmStudioModels = [];
            if (data.models && Array.isArray(data.models)) {
              lmStudioModels = data.models
                .filter(model => model.available && model.type === 'lmstudio')
                .map(model => model.name || model.id);
            } else if (data.data && Array.isArray(data.data)) {
              lmStudioModels = data.data.map(model => model.id || model.name);
            } else if (Array.isArray(data)) {
              lmStudioModels = data.map(model => model.id || model.name);
            }

            settings.value.backend.llm.local.providers.lmstudio.models = lmStudioModels;

            if (!settings.value.backend.llm.local.providers.lmstudio.selected_model && lmStudioModels.length > 0) {
              settings.value.backend.llm.local.providers.lmstudio.selected_model = lmStudioModels[0];
            }
          }
        }
      } catch (error) {
        console.error('Error loading models:', error);
        if (settings.value.backend.llm.provider_type === 'local') {
          const provider = settings.value.backend.llm.local.provider;
          if (provider === 'ollama') {
            settings.value.backend.llm.local.providers.ollama.models = [];
          } else if (provider === 'lmstudio') {
            settings.value.backend.llm.local.providers.lmstudio.models = [];
          }
        }
      }
    };

    // Function to revert a prompt to default
    const revertPromptToDefault = async (promptId) => {
      try {
        const updatedPrompt = await apiClient.revertPrompt(promptId);
        const index = settings.value.prompts.list.findIndex(p => p.id === promptId);
        if (index !== -1) {
          settings.value.prompts.list[index] = updatedPrompt;
        }
        // If this prompt was selected, update the editor
        if (settings.value.prompts.selectedPrompt && settings.value.prompts.selectedPrompt.id === promptId) {
          settings.value.prompts.selectedPrompt = updatedPrompt;
          settings.value.prompts.editedContent = updatedPrompt.content || '';
        }
      } catch (error) {
        console.error('Error reverting prompt to default:', error);
      }
    };

    const onProviderTypeChange = async () => {
      await loadModels();
      await notifyBackendOfProviderChange();
    };

    const onLocalProviderChange = async () => {
      await loadModels();
      await notifyBackendOfProviderChange();
    };

    const onCloudProviderChange = async () => {
      await notifyBackendOfProviderChange();
    };

    const notifyBackendOfProviderChange = async () => {
      try {
        const providerType = settings.value.backend.llm.provider_type;
        const providerData = {
          provider_type: providerType,
          streaming: settings.value.backend.streaming
        };

        if (providerType === 'local') {
          const provider = settings.value.backend.llm.local.provider;
          const providerSettings = settings.value.backend.llm.local.providers[provider];

          providerData.local_provider = provider;
          providerData.local_model = providerSettings.selected_model;
          providerData.local_endpoint = providerSettings.endpoint;
        } else {
          const provider = settings.value.backend.llm.cloud.provider;
          const providerSettings = settings.value.backend.llm.cloud.providers[provider];

          providerData.cloud_provider = provider;
          providerData.cloud_model = providerSettings.selected_model;
          providerData.cloud_api_key = providerSettings.api_key;
          providerData.cloud_endpoint = providerSettings.endpoint;
        }

        const response = await apiClient.post('/api/llm/provider', providerData);
        const result = await response.json();

        // Update health status after provider change
        await checkHealthStatus();
      } catch (error) {
        console.error('Error notifying backend of provider change:', error);
      }
    };

    const getCurrentLLMDisplay = () => {
      if (!settings.value.backend?.llm) return 'Not configured';

      const providerType = settings.value.backend.llm.provider_type || 'local';

      if (providerType === 'local') {
        const provider = settings.value.backend.llm.local?.provider || 'ollama';
        const selectedModel = settings.value.backend.llm.local?.providers?.[provider]?.selected_model;
        const endpoint = settings.value.backend.llm.local?.providers?.[provider]?.endpoint;

        if (selectedModel) {
          const endpointInfo = endpoint ? ` @ ${endpoint}` : '';
          return `${provider.charAt(0).toUpperCase() + provider.slice(1)} - ${selectedModel}${endpointInfo}`;
        } else {
          return `${provider.charAt(0).toUpperCase() + provider.slice(1)} - Not selected`;
        }
      } else {
        const provider = settings.value.backend.llm.cloud?.provider || 'openai';
        const selectedModel = settings.value.backend.llm.cloud?.providers?.[provider]?.selected_model;

        if (selectedModel) {
          return `${provider.charAt(0).toUpperCase() + provider.slice(1)} - ${selectedModel}`;
        } else {
          return `${provider.charAt(0).toUpperCase() + provider.slice(1)} - Not selected`;
        }
      }
    };

    // Developer mode functions
    const updateDeveloperConfig = async () => {
      try {
        await settingsService.updateDeveloperConfig(settings.value.developer);
        if (settings.value.developer.enabled) {
          await loadDeveloperInfo();
        }
      } catch (error) {
        console.error('Error updating developer config:', error);
      }
    };

    const loadDeveloperInfo = async () => {
      try {
        const systemInfo = await settingsService.getSystemInfo();
        const endpoints = await settingsService.getApiEndpoints();
        developerInfo.value = {
          ...systemInfo,
          total_endpoints: endpoints.total_endpoints,
          available_routers: endpoints.routers
        };
      } catch (error) {
        console.error('Error loading developer info:', error);
      }
    };

    const showApiEndpoints = async () => {
      try {
        const endpoints = await settingsService.getApiEndpoints();
        alert(`Found ${endpoints.total_endpoints} API endpoints across ${endpoints.routers?.length || 0} routers. Check console for details.`);
      } catch (error) {
        console.error('Error showing API endpoints:', error);
      }
    };

    // Function to get current embedding configuration display
    const getCurrentEmbeddingConfig = () => {
      if (!settings.value.backend?.llm?.embedding) return 'Not configured';

      const provider = settings.value.backend.llm.embedding.provider || 'ollama';
      const providerSettings = settings.value.backend.llm.embedding.providers?.[provider];
      const selectedModel = providerSettings?.selected_model;

      if (selectedModel) {
        const endpointInfo = providerSettings?.endpoint ? ` @ ${providerSettings.endpoint}` : '';
        return `${provider.charAt(0).toUpperCase() + provider.slice(1)} - ${selectedModel}${endpointInfo}`;
      } else {
        return `${provider.charAt(0).toUpperCase() + provider.slice(1)} - Not selected`;
      }
    };

    // Function to handle embedding provider change
    const onEmbeddingProviderChange = async () => {
      await loadEmbeddingModels();
      await notifyBackendOfEmbeddingChange();
    };

    // Function to notify backend of embedding configuration change
    const notifyBackendOfEmbeddingChange = async () => {
      try {
        const provider = settings.value.backend.llm.embedding.provider;
        const providerSettings = settings.value.backend.llm.embedding.providers[provider];

        const embeddingData = {
          provider: provider,
          model: providerSettings.selected_model,
          endpoint: providerSettings.endpoint
        };

        if (provider === 'openai') {
          embeddingData.api_key = providerSettings.api_key;
        }

        const response = await apiClient.post('/api/llm/embedding', embeddingData);
        const result = await response.json();

        // Update health status after embedding change
        await checkHealthStatus();
      } catch (error) {
        console.error('Error notifying backend of embedding change:', error);
      }
    };

    // Function to load embedding models
    const loadEmbeddingModels = async () => {
      try {
        const provider = settings.value.backend.llm.embedding.provider;

        if (provider === 'ollama') {
          // Load Ollama embedding models
          const data = await apiClient.loadEmbeddingModels();

          if (data.models && Array.isArray(data.models)) {
            settings.value.backend.llm.embedding.providers.ollama.models = data.models;

            // Auto-select first model if none selected
            if (!settings.value.backend.llm.embedding.providers.ollama.selected_model && data.models.length > 0) {
              settings.value.backend.llm.embedding.providers.ollama.selected_model = data.models[0];
            }
          }
        }
        // OpenAI models are predefined, no need to load them
      } catch (error) {
        console.error('Error loading embedding models:', error);
        if (settings.value.backend.llm.embedding.provider === 'ollama') {
          settings.value.backend.llm.embedding.providers.ollama.models = [];
        }
      }
    };

    // Agent management functions
    const loadAgents = async () => {
      try {
        const response = await apiClient.get('/api/agent-config/agents');
        const agentsData = await response.json();
        agentsList.value = agentsData;
        
        // Extract available models from current settings
        if (settings.value.backend?.llm?.local?.providers?.ollama?.models) {
          availableModels.value = settings.value.backend.llm.local.providers.ollama.models;
        }
      } catch (error) {
        console.error('Error loading agents:', error);
        agentsList.value = { agents: [], total_count: 0 };
      }
    };

    const refreshAgents = async () => {
      await loadAgents();
    };

    const toggleAgent = async (agentId, enabled) => {
      try {
        const endpoint = enabled ? `/api/agent-config/agents/${agentId}/enable` : `/api/agent-config/agents/${agentId}/disable`;
        await apiClient.post(endpoint, {});
        await loadAgents(); // Refresh the list
      } catch (error) {
        console.error(`Error ${enabled ? 'enabling' : 'disabling'} agent:`, error);
      }
    };

    const updateAgentModel = async (agentId, model) => {
      try {
        await apiClient.post(`/api/agent-config/agents/${agentId}/model`, {
          agent_id: agentId,
          model: model,
          provider: 'ollama'
        });
        await loadAgents(); // Refresh the list
      } catch (error) {
        console.error('Error updating agent model:', error);
      }
    };

    const updateAgentProvider = async (agentId, provider) => {
      // For now, we'll just update the model since provider change requires more complex logic
      console.log(`Provider change for ${agentId} to ${provider} - requires model reload`);
    };

    const updateAgentPriority = async (agentId, priority) => {
      // TODO: Implement priority update endpoint
      console.log(`Priority change for ${agentId} to ${priority}`);
    };

    const testAllAgents = async () => {
      if (!agentsList.value?.agents) return;
      
      for (const agent of agentsList.value.agents) {
        if (agent.enabled) {
          try {
            await apiClient.get(`/api/agent-config/agents/${agent.id}/health`);
          } catch (error) {
            console.error(`Health check failed for agent ${agent.id}:`, error);
          }
        }
      }
      await loadAgents(); // Refresh after testing
    };

    // Computed properties for agent overview
    const enabledAgentsCount = computed(() => {
      if (!agentsList.value?.agents) return 0;
      return agentsList.value.agents.filter(agent => agent.enabled).length;
    });

    const getOverallHealthStatus = () => {
      if (!agentsList.value?.agents) return 'Unknown';
      const enabledAgents = agentsList.value.agents.filter(agent => agent.enabled);
      const healthyAgents = enabledAgents.filter(agent => agent.status === 'connected');
      
      if (enabledAgents.length === 0) return 'No agents enabled';
      if (healthyAgents.length === enabledAgents.length) return 'All healthy';
      if (healthyAgents.length === 0) return 'All unhealthy';
      return `${healthyAgents.length}/${enabledAgents.length} healthy`;
    };

    const getOverallHealthClass = () => {
      if (!agentsList.value?.agents) return 'unknown';
      const status = getOverallHealthStatus();
      if (status.includes('All healthy')) return 'healthy';
      if (status.includes('All unhealthy')) return 'unhealthy';
      if (status.includes('No agents')) return 'warning';
      return 'partial';
    };

    // Cache management methods
    const addCacheActivity = (message, type = 'info') => {
      const activity = {
        id: Date.now(),
        timestamp: new Date(),
        message,
        type
      };
      cacheActivityLog.value.unshift(activity);
      // Keep only last 20 activities
      if (cacheActivityLog.value.length > 20) {
        cacheActivityLog.value = cacheActivityLog.value.slice(0, 20);
      }
    };

    const refreshCacheStats = async () => {
      try {
        // Get frontend cache stats
        const frontendStats = cacheService.getStats();
        
        // Get backend cache stats (if available)
        let backendStats = null;
        try {
          const response = await apiClient.get('/api/cache/stats');
          backendStats = await response.json();
        } catch (error) {
          console.warn('Backend cache stats not available:', error);
        }

        cacheStats.value = {
          frontend: frontendStats,
          backend: backendStats
        };

        addCacheActivity('Cache statistics refreshed', 'success');
      } catch (error) {
        console.error('Error refreshing cache stats:', error);
        addCacheActivity('Failed to refresh cache statistics', 'error');
      }
    };

    const clearFrontendCache = async () => {
      if (isClearing.value) return;
      isClearing.value = true;

      try {
        cacheService.clear();
        await refreshCacheStats();
        addCacheActivity('Frontend cache cleared completely', 'success');
      } catch (error) {
        console.error('Error clearing frontend cache:', error);
        addCacheActivity('Failed to clear frontend cache', 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const clearFrontendCacheCategory = async (category) => {
      if (isClearing.value) return;
      isClearing.value = true;

      try {
        cacheService.invalidateCategory(category);
        await refreshCacheStats();
        addCacheActivity(`Frontend ${category} cache cleared`, 'success');
      } catch (error) {
        console.error(`Error clearing frontend ${category} cache:`, error);
        addCacheActivity(`Failed to clear ${category} cache`, 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const clearBackendCache = async (type = 'all') => {
      if (isClearing.value) return;
      isClearing.value = true;

      try {
        const endpoint = type === 'all' ? '/api/settings/clear-cache' : `/api/cache/clear/${type}`;
        await apiClient.post(endpoint, {});
        await refreshCacheStats();
        addCacheActivity(`Backend ${type} cache cleared`, 'success');
      } catch (error) {
        console.error(`Error clearing backend ${type} cache:`, error);
        addCacheActivity(`Failed to clear backend ${type} cache`, 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const clearLocalStorage = async () => {
      if (isClearing.value) return;
      isClearing.value = true;

      try {
        localStorage.clear();
        addCacheActivity('Local storage cleared', 'success');
        // Reload settings after clearing localStorage
        await loadSettingsFromBackend();
      } catch (error) {
        console.error('Error clearing local storage:', error);
        addCacheActivity('Failed to clear local storage', 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const clearSessionStorage = async () => {
      if (isClearing.value) return;
      isClearing.value = true;

      try {
        sessionStorage.clear();
        addCacheActivity('Session storage cleared', 'success');
      } catch (error) {
        console.error('Error clearing session storage:', error);
        addCacheActivity('Failed to clear session storage', 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const clearRedisCache = async (database) => {
      if (isClearing.value) return;
      isClearing.value = true;

      try {
        await apiClient.post(`/api/cache/redis/clear/${database}`, {});
        await refreshCacheStats();
        const dbName = database === 'all' ? 'All Redis databases' : `Redis ${database} database`;
        addCacheActivity(`${dbName} cleared`, 'success');
      } catch (error) {
        console.error(`Error clearing Redis ${database} cache:`, error);
        addCacheActivity(`Failed to clear Redis ${database} cache`, 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const clearAllCaches = async () => {
      if (isClearing.value) return;
      
      if (!confirm(' WARNING: This will clear ALL caches and browser storage. This action cannot be undone. Continue?')) {
        return;
      }

      isClearing.value = true;

      try {
        // Clear frontend cache
        cacheService.clear();
        
        // Clear browser storage
        localStorage.clear();
        sessionStorage.clear();
        
        // Clear backend caches
        await apiClient.post('/api/settings/clear-cache', {});
        
        // Clear all Redis databases
        await apiClient.post('/api/cache/redis/clear/all', {});
        
        addCacheActivity(' SYSTEM RESET: All caches cleared', 'warning');
        await refreshCacheStats();
        
        // Reload settings after clearing everything
        await loadSettingsFromBackend();
      } catch (error) {
        console.error('Error during system cache reset:', error);
        addCacheActivity(' System cache reset failed', 'error');
      } finally {
        isClearing.value = false;
      }
    };

    const saveCacheConfig = async () => {
      if (isSaving.value) return;
      isSaving.value = true;

      try {
        // Update cache service configuration
        if (cacheConfig.value.defaultTTLMinutes) {
          cacheService.defaultTTL = cacheConfig.value.defaultTTLMinutes * 60 * 1000;
        }
        
        if (cacheConfig.value.settingsTTLMinutes) {
          cacheService.strategies['/api/settings'] = cacheConfig.value.settingsTTLMinutes * 60 * 1000;
          cacheService.strategies['/api/settings/'] = cacheConfig.value.settingsTTLMinutes * 60 * 1000;
        }

        // Save to backend if available
        try {
          await apiClient.post('/api/cache/config', cacheConfig.value);
        } catch (error) {
          console.warn('Backend cache config save not available:', error);
        }

        addCacheActivity('Cache configuration saved', 'success');
      } catch (error) {
        console.error('Error saving cache configuration:', error);
        addCacheActivity('Failed to save cache configuration', 'error');
      } finally {
        isSaving.value = false;
      }
    };

    const clearActivityLog = () => {
      cacheActivityLog.value = [];
    };

    const formatBytes = (bytes) => {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };

    const formatTime = (date) => {
      if (!date) return 'Never';
      
      // Handle different input types
      let dateObj;
      if (typeof date === 'string') {
        dateObj = new Date(date);
      } else if (date instanceof Date) {
        dateObj = date;
      } else {
        return 'Invalid date';
      }
      
      // Check if date is valid
      if (isNaN(dateObj.getTime())) {
        return 'Invalid date';
      }
      
      return dateObj.toLocaleTimeString();
    };

    // RUM (Real User Monitoring) methods
    const updateRumConfig = async () => {
      if (!settings.value.developer?.rum) return;
      
      try {
        isSaving.value = true;
        
        // Initialize or update RUM agent based on new settings FIRST
        // This ensures RUM is properly enabled/disabled even if backend API fails
        if (settings.value.developer.rum.enabled) {
          await initializeRumAgent();
          addCacheActivity('RUM agent enabled and configured', 'success');
        } else {
          await disableRumAgent();
          // Clear the rum status when disabled
          rumStatus.value = null;
          console.log('[DEBUG] RUM disabled - rumStatus set to null:', rumStatus.value);
          addCacheActivity('RUM agent disabled', 'info');
        }
        
        // Then try to update developer config with RUM settings
        try {
          await settingsService.updateDeveloperConfig(settings.value.developer);
        } catch (configError) {
          console.warn('Backend developer config update failed (this is expected if backend needs restart):', configError.message);
          if (configError.message && configError.message.includes('404')) {
            addCacheActivity('RUM settings applied locally (backend restart required for persistence)', 'warning');
          } else {
            addCacheActivity('RUM settings applied locally, backend update failed', 'warning');
          }
        }
        
      } catch (error) {
        console.error('Error updating RUM configuration:', error);
        addCacheActivity('Failed to update RUM configuration', 'error');
        // Ensure RUM status is cleared if there was an error and RUM should be disabled
        if (!settings.value.developer?.rum?.enabled) {
          rumStatus.value = null;
        }
      } finally {
        isSaving.value = false;
      }
    };

    const initializeRumAgent = async () => {
      try {
        const rumConfig = settings.value.developer.rum;
        
        // Send RUM configuration to backend for logging setup
        await apiClient.post('/api/rum/config', {
          enabled: rumConfig.enabled,
          error_tracking: rumConfig.error_tracking,
          performance_monitoring: rumConfig.performance_monitoring,
          interaction_tracking: rumConfig.interaction_tracking,
          session_recording: rumConfig.session_recording,
          sample_rate: rumConfig.sample_rate,
          max_events_per_session: rumConfig.max_events_per_session,
          debug_mode: rumConfig.debug_mode
        });
        
        // Initialize frontend RUM tracking
        if (typeof window !== 'undefined') {
          window.rumAgent = {
            config: rumConfig,
            sessionId: generateSessionId(),
            startTime: Date.now(),
            eventCount: 0,
            lastEvent: null
          };
          
          // Set up error tracking
          if (rumConfig.error_tracking) {
            window.addEventListener('error', logRumError);
            window.addEventListener('unhandledrejection', logRumPromiseRejection);
          }
          
          // Set up performance monitoring
          if (rumConfig.performance_monitoring) {
            // Monitor API calls
            const originalFetch = window.fetch;
            window.fetch = async (...args) => {
              const startTime = performance.now();
              try {
                const response = await originalFetch(...args);
                const endTime = performance.now();
                logRumPerformance('api_call', {
                  url: args[0],
                  method: args[1]?.method || 'GET',
                  duration: endTime - startTime,
                  status: response.status
                });
                return response;
              } catch (error) {
                logRumError({ error, context: 'fetch_api_call', url: args[0] });
                throw error;
              }
            };
          }
          
          // Set up interaction tracking
          if (rumConfig.interaction_tracking) {
            document.addEventListener('click', logRumInteraction);
            document.addEventListener('submit', logRumFormSubmission);
          }
          
          logRumEvent('rum_agent_initialized', { config: rumConfig });
        }
        
        await refreshRumStatus();
        
      } catch (error) {
        console.error('Error initializing RUM agent:', error);
        // Don't show dashboard if there's an initialization error
        rumStatus.value = null;
        logRumError({ error, context: 'rum_initialization' });
      }
    };

    const disableRumAgent = async () => {
      try {
        // Notify backend that RUM is disabled
        await apiClient.post('/api/rum/disable');
        
        // Clean up frontend RUM tracking
        if (typeof window !== 'undefined' && window.rumAgent) {
          // Remove event listeners
          window.removeEventListener('error', logRumError);
          window.removeEventListener('unhandledrejection', logRumPromiseRejection);
          document.removeEventListener('click', logRumInteraction);
          document.removeEventListener('submit', logRumFormSubmission);
          
          // Restore original fetch
          if (window.originalFetch) {
            window.fetch = window.originalFetch;
          }
          
          logRumEvent('rum_agent_disabled');
          delete window.rumAgent;
        }
        
        // Clear the status completely when disabled
        rumStatus.value = null;
        
      } catch (error) {
        console.error('Error disabling RUM agent:', error);
        // Even on error, clear the status
        rumStatus.value = null;
      }
    };

    const logRumEvent = async (eventType, data = {}) => {
      if (!window.rumAgent || window.rumAgent.eventCount >= window.rumAgent.config.max_events_per_session) {
        return;
      }
      
      // Apply sampling
      if (Math.random() * 100 > window.rumAgent.config.sample_rate) {
        return;
      }
      
      const event = {
        type: eventType,
        timestamp: new Date().toISOString(),
        sessionId: window.rumAgent.sessionId,
        url: window.location.href,
        userAgent: navigator.userAgent,
        data: data
      };
      
      window.rumAgent.eventCount++;
      window.rumAgent.lastEvent = event.timestamp;
      
      if (window.rumAgent.config.debug_mode) {
        console.log('RUM Event:', event);
      }
      
      try {
        // Send to backend for logging
        await apiClient.post('/api/rum/event', event);
      } catch (error) {
        console.warn('Failed to send RUM event to backend:', error);
      }
    };

    const logRumError = (errorEvent) => {
      const errorData = {
        message: errorEvent.message || errorEvent.error?.message || 'Unknown error',
        filename: errorEvent.filename || 'unknown',
        lineno: errorEvent.lineno || 0,
        colno: errorEvent.colno || 0,
        stack: errorEvent.error?.stack || 'No stack trace',
        context: errorEvent.context || 'global'
      };
      
      logRumEvent('error', errorData);
    };

    const logRumPromiseRejection = (promiseRejectionEvent) => {
      const errorData = {
        reason: promiseRejectionEvent.reason?.toString() || 'Unknown promise rejection',
        stack: promiseRejectionEvent.reason?.stack || 'No stack trace'
      };
      
      logRumEvent('promise_rejection', errorData);
    };

    const logRumPerformance = (metricType, data) => {
      logRumEvent('performance', {
        metric_type: metricType,
        ...data
      });
    };

    const logRumInteraction = (event) => {
      const interactionData = {
        element: event.target.tagName,
        id: event.target.id || null,
        className: event.target.className || null,
        text: event.target.textContent?.substring(0, 100) || null,
        coordinates: { x: event.clientX, y: event.clientY }
      };
      
      logRumEvent('interaction', interactionData);
    };

    const logRumFormSubmission = (event) => {
      const formData = {
        action: event.target.action || null,
        method: event.target.method || 'GET',
        fieldCount: event.target.elements.length
      };
      
      logRumEvent('form_submission', formData);
    };

    const refreshRumStatus = async () => {
      try {
        // Only show status if RUM is enabled
        if (!settings.value.developer?.rum?.enabled) {
          rumStatus.value = null;
          return;
        }
        
        if (window.rumAgent) {
          const sessionDuration = Date.now() - window.rumAgent.startTime;
          rumStatus.value = {
            active: true,
            events_count: window.rumAgent.eventCount || 0,
            session_duration: sessionDuration,
            last_event_time: window.rumAgent.lastEvent || null
          };
        } else {
          // If RUM is enabled but agent isn't working, don't show dashboard
          rumStatus.value = null;
        }
      } catch (error) {
        console.error('Error refreshing RUM status:', error);
        // If RUM is disabled, don't show status even on error
        if (!settings.value.developer?.rum?.enabled) {
          rumStatus.value = null;
        } else {
          // Even if RUM is enabled, don't show dashboard if there's an error
          rumStatus.value = null;
        }
      }
    };

    const clearRumData = async () => {
      if (!confirm('Clear all RUM data? This cannot be undone.')) {
        return;
      }
      
      try {
        await apiClient.post('/api/rum/clear');
        if (window.rumAgent) {
          window.rumAgent.eventCount = 0;
          window.rumAgent.lastEvent = null;
        }
        await refreshRumStatus();
        addCacheActivity('RUM data cleared', 'success');
      } catch (error) {
        console.error('Error clearing RUM data:', error);
        addCacheActivity('Failed to clear RUM data', 'error');
      }
    };

    const exportRumData = async () => {
      try {
        const response = await apiClient.get('/api/rum/export');
        const blob = new Blob([JSON.stringify(response.data, null, 2)], {
          type: 'application/json'
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `rum_data_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        addCacheActivity('RUM data exported', 'success');
      } catch (error) {
        console.error('Error exporting RUM data:', error);
        addCacheActivity('Failed to export RUM data', 'error');
      }
    };

    const generateSessionId = () => {
      return 'rum_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
    };

    const formatDuration = (milliseconds) => {
      if (!milliseconds) return '0s';
      const seconds = Math.floor(milliseconds / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      
      if (hours > 0) {
        return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
      } else if (minutes > 0) {
        return `${minutes}m ${seconds % 60}s`;
      } else {
        return `${seconds}s`;
      }
    };

    const forceReloadSettings = async () => {
      try {
        // Force clear all caches
        cacheService.invalidateCategory('settings');
        
        // Get fresh settings from backend without any cache
        const response = await apiClient.get('/api/settings/config', {
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
          }
        });
        const freshSettings = await response.json();
        
        // Create completely new settings object to trigger Vue reactivity
        const newSettings = createEmptySettings();
        
        // FIRST: Deep merge the fresh settings from backend
        Object.assign(newSettings, deepMerge(newSettings, freshSettings));
        
        // THEN: Get fresh developer config and merge it AFTER to preserve RUM settings
        try {
          const developerConfig = await settingsService.getDeveloperConfig();
          if (developerConfig) {
            newSettings.developer = developerConfig;
            console.log('Fresh developer config loaded and preserved:', developerConfig);
          }
        } catch (devError) {
          console.warn('Could not load fresh developer config:', devError);
        }
        
        // Replace the entire settings object to ensure reactivity
        settings.value = newSettings;
        
        // Update localStorage with fresh settings
        localStorage.setItem('chat_settings', JSON.stringify(settings.value));
        
        console.log('Settings force reloaded from backend');
        
      } catch (error) {
        console.error('Error force reloading settings:', error);
        // Fall back to regular reload
        await loadSettingsFromBackend();
      }
    };

    // Initialize cache stats and RUM on component mount
    onMounted(() => {
      refreshCacheStats();
      
      // Initialize RUM if enabled
      console.log('[DEBUG] Component mounted - RUM settings:', {
        enabled: settings.value.developer?.rum?.enabled,
        rumStatus: rumStatus.value
      });
      if (settings.value.developer?.rum?.enabled) {
        initializeRumAgent();
      } else {
        // Ensure RUM status is null when disabled
        rumStatus.value = null;
        console.log('[DEBUG] RUM disabled on mount - rumStatus set to null');
      }
    });

    return {
      settings,
      saveSettings,
      loadModels,
      loadPrompts,
      tabs,
      activeTab,
      activeBackendSubTab,
      corsOriginsString,
      selectPrompt,
      savePrompt,
      revertPromptToDefault,
      isSettingsLoaded,
      settingsLoadingStatus,
      onProviderTypeChange,
      onLocalProviderChange,
      onCloudProviderChange,
      notifyBackendOfProviderChange,
      getCurrentLLMDisplay,
      getCurrentLLMConfig: getCurrentLLMDisplay,
      getCurrentEmbeddingConfig,
      onEmbeddingProviderChange,
      notifyBackendOfEmbeddingChange,
      loadEmbeddingModels,
      healthStatus,
      checkHealthStatus,
      developerInfo,
      updateDeveloperConfig,
      loadDeveloperInfo,
      showApiEndpoints,
      isSaving,
      saveMessage,
      saveMessageType,
      // Agent management
      agentsList,
      availableModels,
      loadAgents,
      refreshAgents,
      toggleAgent,
      updateAgentModel,
      updateAgentProvider,
      updateAgentPriority,
      testAllAgents,
      enabledAgentsCount,
      getOverallHealthStatus,
      getOverallHealthClass,
      getPlaceholder,
      // Cache management exports
      cacheStats,
      isClearing,
      cacheActivityLog,
      cacheConfig,
      refreshCacheStats,
      clearFrontendCache,
      clearFrontendCacheCategory,
      clearBackendCache,
      clearLocalStorage,
      clearSessionStorage,
      clearRedisCache,
      clearAllCaches,
      saveCacheConfig,
      clearActivityLog,
      formatBytes,
      formatTime,
      // RUM management exports
      rumStatus,
      updateRumConfig,
      refreshRumStatus,
      clearRumData,
      exportRumData,
      formatDuration,
      forceReloadSettings
    };
  }
};
</script>

<style scoped>
.settings-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  padding: clamp(10px, 1.5vw, 15px);
  overflow: hidden;
}

.settings-panel h2 {
  margin: 0 0 clamp(10px, 1.5vw, 15px) 0;
  font-size: clamp(16px, 2vw, 20px);
  color: #007bff;
}

.settings-tabs {
  display: flex;
  overflow-x: auto;
  border-bottom: 1px solid #e9ecef;
  margin-bottom: clamp(10px, 1.5vw, 15px);
}

.settings-tabs button {
  background: none;
  border: none;
  padding: clamp(8px, 1vw, 12px) clamp(12px, 1.5vw, 16px);
  cursor: pointer;
  font-size: clamp(12px, 1.5vw, 14px);
  color: #6c757d;
  transition: all 0.3s;
  border-bottom: 2px solid transparent;
  white-space: nowrap;
}

.settings-tabs button.active {
  color: #007bff;
  border-bottom: 2px solid #007bff;
}

.settings-tabs button:hover:not(.active) {
  color: #343a40;
  background-color: rgba(0, 123, 255, 0.05);
}

.settings-content {
  flex: 1;
  overflow-y: auto;
  padding: clamp(5px, 1vw, 10px);
  min-height: 0;
}

.prompts-container {
  display: flex;
  gap: clamp(10px, 1.5vw, 15px);
  height: 400px;
}

.prompts-list {
  flex: 1;
  overflow-y: auto;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  padding: clamp(5px, 0.8vw, 8px);
}

.prompt-item {
  padding: clamp(8px, 1vw, 10px);
  cursor: pointer;
  border-radius: 3px;
  margin-bottom: clamp(3px, 0.5vw, 5px);
  transition: background-color 0.2s;
}

.prompt-item:hover {
  background-color: #e9ecef;
}

.prompt-item.active {
  background-color: #007bff;
  color: white;
}

.prompt-name {
  font-size: clamp(12px, 1.5vw, 14px);
  font-weight: 500;
}

.prompt-type {
  font-size: clamp(10px, 1.2vw, 12px);
  opacity: 0.8;
}

.no-prompts {
  text-align: center;
  color: #6c757d;
  font-style: italic;
  padding: clamp(10px, 1.5vw, 15px);
}

.prompt-editor {
  flex: 2;
  display: flex;
  flex-direction: column;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  padding: clamp(8px, 1vw, 10px);
}

.prompt-editor h4 {
  margin: 0 0 clamp(8px, 1vw, 10px) 0;
  font-size: clamp(14px, 1.6vw, 16px);
  color: #343a40;
}

.prompt-editor textarea {
  flex: 1;
  border: 1px solid #ced4da;
  border-radius: 4px;
  padding: clamp(5px, 0.8vw, 8px);
  font-size: clamp(12px, 1.4vw, 13px);
  resize: none;
  font-family: 'Courier New', Courier, monospace;
}

.prompt-editor textarea:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.editor-actions {
  display: flex;
  justify-content: flex-end;
  gap: clamp(5px, 0.8vw, 8px);
  margin-top: clamp(8px, 1vw, 10px);
}

.editor-actions button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: clamp(5px, 0.6vw, 6px) clamp(10px, 1.2vw, 12px);
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
  font-size: clamp(12px, 1.4vw, 13px);
}

.editor-actions button:hover {
  background-color: #0056b3;
}

.editor-actions button:nth-child(2) {
  background-color: #6c757d;
}

.editor-actions button:nth-child(2):hover {
  background-color: #5a6268;
}

.editor-actions button:nth-child(3) {
  background-color: #dc3545;
}

.editor-actions button:nth-child(3):hover {
  background-color: #c82333;
}

.settings-section {
  margin-bottom: clamp(15px, 2vw, 20px);
}

.settings-section h3 {
  margin: 0 0 clamp(8px, 1.2vw, 12px) 0;
  font-size: clamp(14px, 1.8vw, 16px);
  color: #343a40;
  border-bottom: 1px solid #e9ecef;
  padding-bottom: 5px;
}

.sub-tabs {
  display: flex;
  border-bottom: 1px solid #e9ecef;
  margin-bottom: clamp(10px, 1.5vw, 15px);
}

.sub-tabs button {
  background: none;
  border: none;
  padding: clamp(6px, 0.8vw, 8px) clamp(10px, 1.2vw, 12px);
  cursor: pointer;
  font-size: clamp(12px, 1.4vw, 13px);
  color: #6c757d;
  transition: all 0.3s;
  border-bottom: 2px solid transparent;
}

.sub-tabs button.active {
  color: #007bff;
  border-bottom: 2px solid #007bff;
}

.sub-tabs button:hover:not(.active) {
  color: #343a40;
  background-color: rgba(0, 123, 255, 0.05);
}

.sub-tab-content {
  padding: 0 clamp(5px, 0.5vw, 10px);
}

.setting-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: clamp(8px, 1.2vw, 12px);
  font-size: clamp(12px, 1.5vw, 14px);
}

.setting-item label {
  flex: 1;
  font-weight: 500;
}

.setting-item label.with-description {
  display: flex;
  flex-direction: column;
}

.setting-item label .description {
  font-size: clamp(10px, 1.2vw, 12px);
  color: #6c757d;
  font-weight: normal;
  margin-top: 2px;
}

.setting-item input[type="checkbox"],
.setting-item input[type="radio"] {
  margin: 0;
}

.setting-item input[type="text"],
.setting-item input[type="number"],
.setting-item select {
  flex: 1;
  border: 1px solid #ced4da;
  border-radius: 4px;
  padding: clamp(4px, 0.6vw, 6px) clamp(8px, 1vw, 10px);
  font-size: clamp(12px, 1.5vw, 14px);
}

.setting-item input[type="text"]:focus,
.setting-item input[type="number"]:focus,
.setting-item select:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.settings-actions {
  display: flex;
  justify-content: flex-end;
  padding: clamp(10px, 1.5vw, 15px) 0;
  border-top: 1px solid #e9ecef;
}

.settings-actions button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: clamp(6px, 0.8vw, 8px) clamp(12px, 1.5vw, 16px);
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
  font-size: clamp(12px, 1.5vw, 14px);
}

.settings-actions button:hover {
  background-color: #0056b3;
}

.developer-info {
  margin-top: clamp(15px, 2vw, 20px);
  padding: clamp(10px, 1.5vw, 15px);
  background-color: #f8f9fa;
  border-radius: 4px;
  border: 1px solid #e9ecef;
}

.developer-info h4 {
  margin: 0 0 clamp(10px, 1.5vw, 15px) 0;
  font-size: clamp(14px, 1.6vw, 16px);
  color: #495057;
}

.info-item {
  margin-bottom: clamp(8px, 1.2vw, 10px);
  font-size: clamp(12px, 1.4vw, 13px);
}

.info-item strong {
  color: #495057;
}

@media (max-width: 768px) {
  .settings-tabs {
    grid-template-columns: 1fr;
  }

  .nav-title {
    font-size: 24px;
  }

  .tab-btn {
    padding: 12px;
  }

  .settings-actions {
    flex-direction: column;
    gap: 16px;
    align-items: stretch;
  }

  .action-buttons {
    justify-content: center;
  }

  .setting-item {
    flex-direction: column;
    align-items: stretch;
    gap: 12px;
  }

  .setting-item label {
    margin-right: 0;
  }

  .setting-item input[type="text"],
  .setting-item input[type="number"],
  .setting-item input[type="password"],
  .setting-item select {
    max-width: none;
  }
}

/* Save button and message styles */
.save-button {
  background-color: #007bff;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.2s, opacity 0.2s;
}

.save-button:hover:not(:disabled) {
  background-color: #0056b3;
}

.save-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.save-message {
  margin-top: 10px;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
}

.save-message.success {
  background-color: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.save-message.error {
  background-color: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}


.settings-actions {
  flex-direction: column;
  align-items: flex-end;
  gap: 10px;
}

/* LLM and Embedding status display styles */
.llm-status-display,
.embedding-status-display {
  background-color: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  padding: 10px;
  margin: 5px 0;
}

.status-line {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
}

.status-line:last-child {
  margin-bottom: 0;
}

.status-label {
  font-weight: 500;
  color: #495057;
}

.status-value {
  font-family: 'Courier New', Courier, monospace;
  font-size: 13px;
}

.status-value.connected {
  color: #28a745;
  font-weight: 500;
}

.status-value.disconnected {
  color: #dc3545;
  font-weight: 500;
}

/* Settings loading and status styles */
.settings-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 40px;
  color: #6c757d;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #e9ecef;
  border-top: 4px solid #007bff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 15px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.settings-status {
  display: flex;
  align-items: center;
  padding: 10px 15px;
  margin-bottom: 15px;
  border-radius: 4px;
  font-size: 14px;
}

.settings-status.offline {
  background-color: #fff3cd;
  border: 1px solid #ffeaa7;
  color: #856404;
}

.settings-status i {
  margin-right: 8px;
}

/* Agent Settings Styles */
.agents-overview {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.agents-summary {
  display: flex;
  gap: 20px;
  padding: 15px;
  background-color: #f8f9fa;
  border-radius: 6px;
  border: 1px solid #e9ecef;
}

.summary-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
}

.summary-label {
  font-size: 12px;
  color: #6c757d;
  font-weight: 500;
}

.summary-value {
  font-size: 16px;
  font-weight: 600;
  color: #495057;
}

.summary-value.healthy { color: #28a745; }
.summary-value.unhealthy { color: #dc3545; }
.summary-value.partial { color: #ffc107; }
.summary-value.warning { color: #fd7e14; }
.summary-value.unknown { color: #6c757d; }

.agents-list {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.agent-card {
  border: 1px solid #e9ecef;
  border-radius: 8px;
  padding: 15px;
  background-color: white;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.agent-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.agent-header h4 {
  margin: 0;
  font-size: 16px;
  color: #343a40;
}

.agent-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: 0.4s;
  border-radius: 24px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.4s;
  border-radius: 50%;
}

input:checked + .toggle-slider {
  background-color: #007bff;
}

input:checked + .toggle-slider:before {
  transform: translateX(20px);
}

.agent-status {
  font-size: 12px;
  font-weight: 500;
  padding: 4px 8px;
  border-radius: 12px;
}

.agent-status.connected {
  background-color: #d4edda;
  color: #155724;
}

.agent-status.disconnected {
  background-color: #f8d7da;
  color: #721c24;
}

.agent-description {
  font-size: 14px;
  color: #6c757d;
  margin: 10px 0;
}

.agent-config {
  display: grid;
  grid-template-columns: 1fr 1fr 120px;
  gap: 10px;
  margin: 15px 0;
}

.config-item {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.config-item label {
  font-size: 12px;
  font-weight: 500;
  color: #495057;
}

.config-item select,
.config-item input {
  padding: 6px 8px;
  border: 1px solid #ced4da;
  border-radius: 4px;
  font-size: 13px;
}

.agent-tasks {
  margin: 10px 0;
}

.tasks-label {
  font-size: 12px;
  font-weight: 500;
  color: #495057;
  margin-right: 8px;
}

.tasks-tags {
  display: inline-flex;
  flex-wrap: wrap;
  gap: 5px;
}

.task-tag {
  font-size: 11px;
  background-color: #e7f3ff;
  color: #0066cc;
  padding: 3px 8px;
  border-radius: 12px;
  border: 1px solid #b3d9ff;
}

.agent-performance {
  display: flex;
  gap: 15px;
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid #f0f0f0;
}

.performance-item {
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.perf-label {
  font-size: 11px;
  color: #6c757d;
  font-weight: 500;
}

.perf-value {
  font-size: 13px;
  font-weight: 600;
  font-family: 'Courier New', monospace;
  color: #495057;
}

.agents-actions {
  display: flex;
  gap: 10px;
  justify-content: center;
  padding: 15px;
  border-top: 1px solid #e9ecef;
}

.agents-actions button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 13px;
  transition: background-color 0.2s;
}

.refresh-button {
  background-color: #007bff;
  color: white;
}

.refresh-button:hover {
  background-color: #0056b3;
}

.test-button {
  background-color: #28a745;
  color: white;
}

.test-button:hover {
  background-color: #218838;
}

.agents-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 40px;
  color: #6c757d;
}

/* Cache Management Styles */
.cache-stats {
  margin-bottom: 2rem;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #e9ecef;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1rem;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: white;
  border-radius: 4px;
  border: 1px solid #dee2e6;
}

.stat-item label {
  font-weight: 500;
  color: #495057;
}

.stat-item span {
  font-weight: 600;
  color: #007bff;
}

.refresh-btn {
  background-color: #17a2b8;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s;
}

.refresh-btn:hover {
  background-color: #138496;
}
.cache-info {
  margin-bottom: 1rem;
  padding: 0.75rem;
  background: white;
  border: 1px solid #dee2e6;
  border-radius: 6px;
}
.cache-size-info {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  align-items: center;
}
.cache-label {
  font-weight: 500;
  color: #6c757d;
  font-size: 0.9rem;
}
.cache-size,
.cache-entries {
  font-weight: 600;
  color: #007bff;
  font-size: 0.9rem;
}
.cache-status.online {
  color: #28a745;
  font-weight: 600;
}
.cache-status.offline {
  color: #dc3545;
  font-weight: 600;
}
.loading-dots {
  animation: pulse 1s infinite;
  color: #6c757d;
  font-size: 0.8rem;
}
@keyframes pulse {
  0%, 50%, 100% { opacity: 1; }
  25%, 75% { opacity: 0.5; }
}

.cache-actions {
  margin-bottom: 2rem;
}

.cache-action-group {
  margin-bottom: 1.5rem;
  padding: 1rem;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  background: #fafbfc;
}

.cache-action-group h5 {
  margin: 0 0 1rem 0;
  color: #495057;
  font-size: 1.1rem;
  font-weight: 600;
}

.action-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.clear-btn {
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.clear-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.clear-btn.category-btn {
  background-color: #6c757d;
  color: white;
}

.clear-btn.category-btn:hover:not(:disabled) {
  background-color: #5a6268;
}

.clear-btn:not(.category-btn):not(.danger):not(.danger-full) {
  background-color: #007bff;
  color: white;
}

.clear-btn:not(.category-btn):not(.danger):not(.danger-full):hover:not(:disabled) {
  background-color: #0056b3;
}

.clear-btn.danger {
  background-color: #fd7e14;
  color: white;
}

.clear-btn.danger:hover:not(:disabled) {
  background-color: #e8650e;
}

.clear-btn.danger-full {
  background-color: #dc3545;
  color: white;
  font-weight: 600;
}

.clear-btn.danger-full:hover:not(:disabled) {
  background-color: #c82333;
}

.cache-config {
  margin-bottom: 2rem;
  padding: 1rem;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  background: #f8f9fa;
}

.save-btn {
  background-color: #28a745;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 1rem;
}

.save-btn:hover:not(:disabled) {
  background-color: #218838;
}

.save-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.cache-activity {
  padding: 1rem;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  background: #ffffff;
}

.activity-log {
  max-height: 200px;
  overflow-y: auto;
  margin-bottom: 1rem;
}

.activity-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 0.5rem;
  border-bottom: 1px solid #f1f3f4;
}

.activity-item:last-child {
  border-bottom: none;
}

.timestamp {
  font-size: 0.8rem;
  color: #6c757d;
  min-width: 80px;
}

.action {
  flex: 1;
  font-size: 0.9rem;
}

.action.success {
  color: #28a745;
}

.action.error {
  color: #dc3545;
}

.action.warning {
  color: #fd7e14;
}

.action.info {
  color: #17a2b8;
}

.clear-log-btn {
  background-color: #6c757d;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: background-color 0.2s;
}

.clear-log-btn:hover {
  background-color: #5a6268;
}

/* Logging Configuration Styles */
.logging-section {
  margin-bottom: 2rem;
  padding: 1rem;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  background: #fafbfc;
}

.logging-section h4 {
  margin: 0 0 1rem 0;
  color: #495057;
  font-size: 1.1rem;
  font-weight: 600;
  border-bottom: 1px solid #e9ecef;
  padding-bottom: 0.5rem;
}

.log-files-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1rem;
  margin-bottom: 1rem;
}

.rotation-config,
.startup-rotation-config {
  margin-top: 1rem;
  padding: 1rem;
  background: #ffffff;
  border: 1px solid #dee2e6;
  border-radius: 6px;
}

.rotation-config .setting-item,
.startup-rotation-config .setting-item {
  margin-bottom: 0.75rem;
}

.rotation-config .setting-item:last-child,
.startup-rotation-config .setting-item:last-child {
  margin-bottom: 0;
}

/* RUM Settings Styles */
.rum-settings {
  margin-top: 2rem;
  padding: 1rem;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  background: #f8f9fa;
}

.rum-settings h4 {
  margin: 0 0 1rem 0;
  color: #495057;
  font-size: 1.1rem;
  font-weight: 600;
  border-bottom: 1px solid #e9ecef;
  padding-bottom: 0.5rem;
}

.rum-config {
  margin-top: 1rem;
  padding: 1rem;
  background: #ffffff;
  border: 1px solid #dee2e6;
  border-radius: 6px;
}

.rum-status {
  margin-top: 1.5rem;
  padding: 1rem;
  background: #e8f4f8;
  border: 1px solid #b8daff;
  border-radius: 6px;
}

.rum-status h5 {
  margin: 0 0 1rem 0;
  color: #004085;
  font-size: 1rem;
  font-weight: 600;
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1rem;
}

.status-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: white;
  border-radius: 4px;
  border: 1px solid #dee2e6;
}

.status-item label {
  font-weight: 500;
  color: #495057;
}

.status-value {
  font-weight: 600;
  color: #007bff;
}

.status-value.active {
  color: #28a745;
}

.status-value.inactive {
  color: #6c757d;
}

.rum-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 1rem;
}

.export-btn {
  background-color: #17a2b8;
  color: white;
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: background-color 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.export-btn:hover {
  background-color: #138496;
}

/* Disabled section styles */
.disabled-section {
  opacity: 0.6;
  pointer-events: none;
  position: relative;
}

.disabled-section::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  pointer-events: none;
}

.disabled-section input,
.disabled-section button,
.disabled-section select {
  cursor: not-allowed;
}

.disabled-section label {
  color: #6c757d;
}

.disabled-section .description {
  color: #adb5bd;
}
</style>
