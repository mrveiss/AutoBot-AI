{
  "command": "wget",
  "section": 1,
  "title": "Wget",
  "description": "The non-interactive network downloader.",
  "synopsis": "wget [option]... [URL]...",
  "options": [
    {
      "flag": "-V",
      "description": "--version Display the version of Wget."
    },
    {
      "flag": "-h",
      "description": "--help Print a help message describing all of Wget's command-line options."
    },
    {
      "flag": "-b",
      "description": "--background Go to background immediately after startup. If no output file is specified via the -o, output is redirected to wget-log."
    },
    {
      "flag": "-e",
      "description": "command"
    },
    {
      "flag": "--execute",
      "description": "command Execute command as if it were a part of .wgetrc. A command thus invoked will be executed after the commands in .wgetrc, thus taking precedence over them. If you need to specify more than one wgetrc command, use multiple instances of -e. Logging and Input File Options"
    },
    {
      "flag": "-o",
      "description": "logfile"
    },
    {
      "flag": "-a",
      "description": "logfile"
    },
    {
      "flag": "-d",
      "description": "--debug Turn on debug output, meaning various information important to the developers of Wget if it does not work properly. Your system administrator may have chosen to compile Wget without debug support, in which case -d will not work. Please note that compiling with debug support is always safe---Wget compiled with the debug support will not print any debug info unless requested with -d."
    },
    {
      "flag": "-q",
      "description": "--quiet Turn off Wget's output."
    },
    {
      "flag": "-v",
      "description": "--verbose Turn on verbose output, with all the available data. The default output is verbose."
    },
    {
      "flag": "-nv",
      "description": "--no-verbose Turn off verbose without being completely quiet (use -q for that), which means that error messages and basic information still get printed."
    },
    {
      "flag": "-i",
      "description": "file"
    },
    {
      "flag": "--keep-badhash",
      "description": "Keeps downloaded Metalink's files with a bad hash. It appends .badhash to the name of Metalink's files which have a checksum mismatch, except without overwriting existing files."
    },
    {
      "flag": "--metalink-over-http",
      "description": "Issues HTTP HEAD request instead of GET and extracts Metalink metadata from response headers. Then it switches to Metalink download. If no valid Metalink metadata is found, it falls back to ordinary HTTP download. Enables Content-Type: application/metalink4+xml files download/processing."
    },
    {
      "flag": "--preferred-location",
      "description": "Set preferred location for Metalink resources. This has effect if multiple resources with same priority are available."
    },
    {
      "flag": "--xattr",
      "description": "Enable use of file system's extended attributes to save the original URL and the Referer HTTP header value if used. Be aware that the URL might contain private information like access tokens or credentials."
    },
    {
      "flag": "-F",
      "description": "--force-html When input is read from a file, force it to be treated as an HTML file. This enables you to retrieve relative links from existing HTML files on your local disk, by adding \"<base href=\"url\">\" to HTML, or using the --base command-line option."
    },
    {
      "flag": "-B",
      "description": "URL"
    },
    {
      "flag": "--no-config",
      "description": "is ignored."
    },
    {
      "flag": "-t",
      "description": "number"
    },
    {
      "flag": "-O",
      "description": "file"
    },
    {
      "flag": "-nc",
      "description": "--no-clobber If a file is downloaded more than once in the same directory, Wget's behavior depends on a few options, including -nc. In certain cases, the local file will be clobbered, or overwritten, upon repeated download. In other cases it will be preserved. When running Wget without -N, -nc, -r, or -p, downloading the same file in the same directory will result in the original copy of file being preserved and the second copy being named file.1. If that file is downloaded yet again, the third copy will be named file.2, and so on. (This is also the behavior with -nd, even if -r or -p are in effect.) When -nc is specified, this behavior is suppressed, and Wget will refuse to download newer copies of file. Therefore, \"\"no-clobber\"\" is actually a misnomer in this mode---it's not clobbering that's prevented (as the numeric suffixes were already preventing clobbering), but rather the multiple version saving that's prevented. When running Wget with -r or -p, but without -N, -nd, or -nc, re-downloading a file will result in the new copy simply overwriting the old. Adding -nc will prevent this behavior, instead causing the original version to be preserved and any newer copies on the server to be ignored. When running Wget with -N, with or without -r or -p, the decision as to whether or not to download a newer copy of a file depends on the local and remote timestamp and size of the file."
    },
    {
      "flag": "-nc",
      "description": "may not be specified at the same time as -N. A combination with -O/--output-document is only accepted if the given output file does not exist. Note that when -nc is specified, files with the suffixes .html or .htm will be loaded from the local disk and parsed as if they had been retrieved from the Web."
    },
    {
      "flag": "--no-netrc",
      "description": "Do not try to obtain credentials from .netrc file. By default .netrc file is searched for credentials in case none have been passed on command line and authentication is required."
    },
    {
      "flag": "-c",
      "description": "--continue Continue getting a partially-downloaded file. This is useful when you want to finish up a download started by a previous instance of Wget, or by another program. For instance: wget -c ftp://sunsite.doc.ic.ac.uk/ls-lR.Z If there is a file named ls-lR.Z in the current directory, Wget will assume that it is the first portion of the remote file, and will ask the server to continue the retrieval from an offset equal to the length of the local file. Note that you don't need to specify this option if you just want the current invocation of Wget to retry downloading a file should the connection be lost midway through. This is the default behavior. -c only affects resumption of downloads started prior to this invocation of Wget, and whose local files are still sitting around. Without -c, the previous example would just download the remote file to ls-lR.Z.1, leaving the truncated ls-lR.Z file alone. If you use -c on a non-empty file, and the server does not support continued downloading, Wget will restart the download from scratch and overwrite the existing file entirely. Beginning with Wget 1.7, if you use -c on a file which is of equal size as the one on the server, Wget will refuse to download the file and print an explanatory message. The same happens when the file is smaller on the server than locally (presumably because it was changed on the server since your last download attempt)---because \"continuing\" is not meaningful, no download occurs. On the other side of the coin, while using -c, any file that's bigger on the server than locally will be considered an incomplete download and only \"(length(remote) - length(local))\" bytes will be downloaded and tacked onto the end of the local file. This behavior can be desirable in certain cases---for instance, you can use wget -c to download just the new portion that's been appended to a data collection or log file. However, if the file is bigger on the server because it's been changed, as opposed to just appended to, you'll end up with a garbled file. Wget has no way of verifying that the local file is really a valid prefix of the remote file. You need to be especially careful of this when using -c in conjunction with -r, since every file will be considered as an \"incomplete download\" candidate. Another instance where you'll get a garbled file if you try to use -c is if you have a lame HTTP proxy that inserts a \"transfer interrupted\" string into the local file. In the future a \"rollback\" option may be added to deal with this case. Note that -c only works with FTP servers and with HTTP servers that support the \"Range\" header."
    },
    {
      "flag": "--start-pos",
      "description": "has higher precedence over --continue. When --start-pos and --continue are both specified, wget will emit a warning then proceed as if --continue was absent. Server support for continued download is required, otherwise --start-pos cannot help. See -c for details."
    },
    {
      "flag": "--show-progress",
      "description": "Force wget to display the progress bar in any verbosity. By default, wget only displays the progress bar in verbose mode. One may however, want wget to display the progress bar on screen in conjunction with any other verbosity modes like"
    },
    {
      "flag": "--no-verbose",
      "description": "or --quiet. This is often a desired a property when invoking wget to download several small/large files. In such a case, wget could simply be invoked with this parameter to get a much cleaner output on the screen. This option will also force the progress bar to be printed to stderr when used alongside the --output-file option."
    },
    {
      "flag": "-N",
      "description": "--timestamping Turn on time-stamping."
    },
    {
      "flag": "--no-if-modified-since",
      "description": "Do not send If-Modified-Since header in -N mode. Send preliminary HEAD request instead. This has only effect in -N mode."
    },
    {
      "flag": "--no-use-server-timestamps",
      "description": "Don't set the local file's timestamp by the one on the server. By default, when a file is downloaded, its timestamps are set to match those from the remote file. This allows the use of --timestamping on subsequent invocations of wget. However, it is sometimes useful to base the local file's timestamp on when it was actually downloaded; for that purpose, the --no-use-server-timestamps option has been provided."
    },
    {
      "flag": "-S",
      "description": "--server-response Print the headers sent by HTTP servers and responses sent by FTP servers."
    },
    {
      "flag": "--spider",
      "description": "When invoked with this option, Wget will behave as a Web spider, which means that it will not download the pages, just check that they are there. For example, you can use Wget to check your bookmarks: wget --spider --force-html -i bookmarks.html This feature needs much more work for Wget to get close to the functionality of real web spiders."
    },
    {
      "flag": "-T",
      "description": "seconds"
    },
    {
      "flag": "-w",
      "description": "seconds"
    },
    {
      "flag": "--random-wait",
      "description": "Some web sites may perform log analysis to identify retrieval programs such as Wget by looking for statistically significant similarities in the time between requests. This option causes the time between requests to vary between 0.5 and 1.5 * wait seconds, where wait was specified using the --wait option, in order to mask Wget's presence from such analysis. A 2001 article in a publication devoted to development on a popular consumer platform provided code to perform this analysis on the fly. Its author suggested blocking at the class C address level to ensure automated retrieval programs were blocked despite changing DHCP-supplied addresses. The --random-wait option was inspired by this ill-advised recommendation to block many unrelated users from a web site due to the actions of one."
    },
    {
      "flag": "--no-proxy",
      "description": "Don't use proxies, even if the appropriate *_proxy environment variable is defined."
    },
    {
      "flag": "-Q",
      "description": "quota"
    },
    {
      "flag": "--no-dns-cache",
      "description": "Turn off caching of DNS lookups. Normally, Wget remembers the IP addresses it looked up from DNS so it doesn't have to repeatedly contact the DNS server for the same (typically small) set of hosts it retrieves from. This cache exists in memory only; a new Wget run will contact DNS again. However, it has been reported that in some situations it is not desirable to cache host names, even for the duration of a short-running application like Wget. With this option Wget issues a new DNS lookup (more precisely, a new call to \"gethostbyname\" or \"getaddrinfo\") each time it makes a new connection. Please note that this option will not affect caching that might be performed by the resolving library or by an external caching layer, such as NSCD. If you don't understand exactly what this option does, you probably won't need it."
    },
    {
      "flag": "-4",
      "description": "--inet4-only"
    },
    {
      "flag": "-6",
      "description": "--inet6-only Force connecting to IPv4 or IPv6 addresses. With --inet4-only or -4, Wget will only connect to IPv4 hosts, ignoring AAAA records in DNS, and refusing to connect to IPv6 addresses specified in URLs. Conversely, with --inet6-only or -6, Wget will only connect to IPv6 hosts and ignore A records and IPv4 addresses. Neither options should be needed normally. By default, an IPv6-aware Wget will use the address family specified by the host's DNS record. If the DNS responds with both IPv4 and IPv6 addresses, Wget will try them in sequence until it finds one it can connect to. (Also see \"--prefer-family\" option described below.) These options can be used to deliberately force the use of IPv4 or IPv6 address families on dual family systems, usually to aid debugging or to deal with broken network configuration. Only one of --inet6-only and --inet4-only may be specified at the same time. Neither option is available in Wget compiled without IPv6 support."
    },
    {
      "flag": "--retry-connrefused",
      "description": "Consider \"connection refused\" a transient error and try again. Normally Wget gives up on a URL when it is unable to connect to the site because failure to connect is taken as a sign that the server is not running at all and that retries would not help. This option is for mirroring unreliable sites whose servers tend to disappear for short periods of time."
    },
    {
      "flag": "--ask-password",
      "description": "Prompt for a password for each connection established. Cannot be specified when --password is being used, because they are mutually exclusive."
    },
    {
      "flag": "--no-iri",
      "description": "Turn off internationalized URI (IRI) support. Use --iri to turn it on. IRI support is activated by default. You can set the default state of IRI support using the \"iri\" command in .wgetrc. That setting may be overridden from the command line."
    },
    {
      "flag": "--unlink",
      "description": "Force Wget to unlink file instead of clobbering existing file. This option is useful for downloading to the directory with hardlinks. Directory Options"
    },
    {
      "flag": "-nd",
      "description": "--no-directories Do not create a hierarchy of directories when retrieving recursively. With this option turned on, all files will get saved to the current directory, without clobbering (if a name shows up more than once, the filenames will get extensions .n)."
    },
    {
      "flag": "-x",
      "description": "--force-directories The opposite of -nd---create a hierarchy of directories, even if one would not have been created otherwise. E.g. wget -x http://fly.srk.fer.hr/robots.txt will save the downloaded file to fly.srk.fer.hr/robots.txt."
    },
    {
      "flag": "-nH",
      "description": "--no-host-directories Disable generation of host-prefixed directories. By default, invoking Wget with -r http://fly.srk.fer.hr/ will create a structure of directories beginning with fly.srk.fer.hr/. This option disables such behavior."
    },
    {
      "flag": "--protocol-directories",
      "description": "Use the protocol name as a directory component of local file names. For example, with this option, wget -r http://host will save to http/host/... rather than just to host/...."
    },
    {
      "flag": "-nH",
      "description": "-> pub/xemacs/"
    },
    {
      "flag": "-nH",
      "description": "--cut-dirs=1 -> xemacs/"
    },
    {
      "flag": "-nH",
      "description": "--cut-dirs=2 -> ."
    },
    {
      "flag": "-P",
      "description": "prefix"
    },
    {
      "flag": "-E",
      "description": "--adjust-extension If a file of type application/xhtml+xml or text/html is downloaded and the URL does not end with the regexp \\.[Hh][Tt][Mm][Ll]?, this option will cause the suffix .html to be appended to the local filename. This is useful, for instance, when you're mirroring a remote site that uses .asp pages, but you want the mirrored pages to be viewable on your stock Apache server. Another good use for this is when you're downloading CGI-generated materials. A URL like http://site.com/article.cgi?25 will be saved as article.cgi?25.html. Note that filenames changed in this way will be re-downloaded every time you re-mirror a site, because Wget can't tell that the local X.html file corresponds to remote URL X (since it doesn't yet know that the URL produces output of type text/html or application/xhtml+xml. As of version 1.12, Wget will also ensure that any downloaded files of type text/css end in the suffix .css, and the option was renamed from --html-extension, to better reflect its new behavior. The old option name is still acceptable, but should now be considered deprecated. As of version 1.19.2, Wget will also ensure that any downloaded files with a \"Content-Encoding\" of br, compress, deflate or gzip end in the suffix .br, .Z, .zlib and .gz respectively. At some point in the future, this option may well be expanded to include suffixes for other types of content, including content types that are not parsed by Wget."
    },
    {
      "flag": "--no-http-keep-alive",
      "description": "Turn off the \"keep-alive\" feature for HTTP downloads. Normally, Wget asks the server to keep the connection open so that, when you download more than one document from the same server, they get transferred over the same TCP connection. This saves time and at the same time reduces the load on the server. This option is useful when, for some reason, persistent (keep-alive) connections don't work for you, for example due to a server bug or due to the inability of server-side scripts to cope with the connections."
    },
    {
      "flag": "--no-cache",
      "description": "Disable server-side cache. In this case, Wget will send the remote server appropriate directives (Cache-Control: no-cache and Pragma: no-cache) to get the file from the remote service, rather than returning the cached version. This is especially useful for retrieving and flushing out-of-date documents on proxy servers. Caching is allowed by default."
    },
    {
      "flag": "--no-cookies",
      "description": "Disable the use of cookies. Cookies are a mechanism for maintaining server-side state. The server sends the client a cookie using the \"Set-Cookie\" header, and the client responds with the same cookie upon further requests. Since cookies allow the server owners to keep track of visitors and for sites to exchange this information, some consider them a breach of privacy. The default is to use cookies; however, storing cookies is not on by default."
    },
    {
      "flag": "--load-cookies",
      "description": "file Load cookies from file before the first HTTP retrieval. file is a textual file in the format originally used by Netscape's cookies.txt file. You will typically use this option when mirroring sites that require that you be logged in to access some or all of their content. The login process typically works by the web server issuing an HTTP cookie upon receiving and verifying your credentials. The cookie is then resent by the browser when accessing that part of the site, and so proves your identity. Mirroring such a site requires Wget to send the same cookies your browser sends when communicating with the site. This is achieved by --load-cookies---simply point Wget to the location of the cookies.txt file, and it will send the same cookies your browser would send in the same situation. Different browsers keep textual cookie files in different locations: \"Netscape 4.x.\" The cookies are in ~/.netscape/cookies.txt. \"Mozilla and Netscape 6.x.\" Mozilla's cookie file is also named cookies.txt, located somewhere under ~/.mozilla, in the directory of your profile. The full path usually ends up looking somewhat like ~/.mozilla/default/some-weird-string/cookies.txt. \"Internet Explorer.\" You can produce a cookie file Wget can use by using the File menu, Import and Export, Export Cookies. This has been tested with Internet Explorer 5; it is not guaranteed to work with earlier versions. \"Other browsers.\" If you are using a different browser to create your cookies, --load-cookies will only work if you can locate or produce a cookie file in the Netscape format that Wget expects. If you cannot use --load-cookies, there might still be an alternative. If your browser supports a \"cookie manager\", you can use it to view the cookies used when accessing the site you're mirroring. Write down the name and value of the cookie, and manually instruct Wget to send those cookies, bypassing the \"official\" cookie support: wget --no-cookies --header \"Cookie: <name>=<value>\""
    },
    {
      "flag": "--save-cookies",
      "description": "file Save cookies to file before exiting. This will not save cookies that have expired or that have no expiry time (so-called \"session cookies\"), but also see --keep-session-cookies."
    },
    {
      "flag": "--keep-session-cookies",
      "description": "When specified, causes --save-cookies to also save session cookies. Session cookies are normally not saved because they are meant to be kept in memory and forgotten when you exit the browser. Saving them is useful on sites that require you to log in or to visit the home page before you can access some pages. With this option, multiple Wget runs are considered a single browser session as far as the site is concerned. Since the cookie file format does not normally carry session cookies, Wget marks them with an expiry timestamp of 0. Wget's --load-cookies recognizes those as session cookies, but it might confuse other browsers. Also note that cookies so loaded will be treated as other session cookies, which means that if you want --save-cookies to preserve them again, you must use --keep-session-cookies again."
    },
    {
      "flag": "--ignore-length",
      "description": "Unfortunately, some HTTP servers (CGI programs, to be more precise) send out bogus \"Content-Length\" headers, which makes Wget go wild, as it thinks not all the document was retrieved. You can spot this syndrome if Wget retries getting the same document again and again, each time claiming that the (otherwise normal) connection has closed on the very same byte. With this option, Wget will ignore the \"Content-Length\" header---as if it never existed."
    },
    {
      "flag": "--save-headers",
      "description": "Save the headers sent by the HTTP server to the file, preceding the actual contents, with an empty line as the separator."
    },
    {
      "flag": "-U",
      "description": "agent-string"
    },
    {
      "flag": "--post-data",
      "description": "'user=foo&password=bar' \\ http://example.com/auth.php # Now grab the page or pages we care about. wget --load-cookies cookies.txt \\"
    },
    {
      "flag": "-p",
      "description": "http://example.com/interesting/article.php If the server is using session cookies to track user authentication, the above will not work because --save-cookies will not save them (and neither will browsers) and the cookies.txt file will be empty. In that case use --keep-session-cookies along with --save-cookies to force saving of session cookies."
    },
    {
      "flag": "--body-file",
      "description": "should be specified. If Wget is redirected after the request is completed, Wget will suspend the current method and send a GET request till the redirection is completed. This is true for all redirection response codes except 307 Temporary Redirect which is used to explicitly specify that the request method should not change. Another exception is when the method is set to \"POST\", in which case the redirection rules specified under --post-data are followed."
    },
    {
      "flag": "--content-disposition",
      "description": "If this is set to on, experimental (not fully-functional) support for \"Content-Disposition\" headers is enabled. This can currently result in extra round-trips to the server for a \"HEAD\" request, and is known to suffer from a few bugs, which is why it is not currently enabled by default. This option is useful for some file-downloading CGI programs that use \"Content-Disposition\" headers to describe what the name of a downloaded file should be. When combined with --metalink-over-http and --trust-server-names, a Content-Type: application/metalink4+xml file is named using the \"Content-Disposition\" filename field, if available."
    },
    {
      "flag": "--content-on-error",
      "description": "If this is set to on, wget will not skip the content when the server responds with a http status code that indicates error."
    },
    {
      "flag": "--trust-server-names",
      "description": "If this is set, on a redirect, the local file name will be based on the redirection URL. By default the local file name is based on the original URL. When doing recursive retrieving this can be helpful because in many web sites redirected URLs correspond to an underlying file structure, while link URLs do not."
    },
    {
      "flag": "--auth-no-challenge",
      "description": "If this option is given, Wget will send Basic HTTP authentication information (plaintext username and password) for all requests, just like Wget 1.10.2 and prior did by default. Use of this option is not recommended, and is intended only to support some few obscure servers, which never send HTTP authentication challenges, but accept unsolicited auth info, say, in addition to form-based authentication."
    },
    {
      "flag": "--retry-on-host-error",
      "description": "Consider host errors, such as \"Temporary failure in name resolution\", as non-fatal, transient errors."
    },
    {
      "flag": "--https-only",
      "description": "When in recursive mode, only HTTPS links are followed."
    },
    {
      "flag": "--ciphers",
      "description": "Set the cipher list string. Typically this string sets the cipher suites and other SSL/TLS options that the user wish should be used, in a set order of preference (GnuTLS calls it 'priority string'). This string will be fed verbatim to the SSL/TLS engine (OpenSSL or GnuTLS) and hence its format and syntax is dependent on that. Wget will not process or manipulate it in any way. Refer to the OpenSSL or GnuTLS documentation for more information."
    },
    {
      "flag": "--no-check-certificate",
      "description": "Don't check the server certificate against the available certificate authorities. Also don't require the URL host name to match the common name presented by the certificate. As of Wget 1.10, the default is to verify the server's certificate against the recognized certificate authorities, breaking the SSL handshake and aborting the download if the verification fails. Although this provides more secure downloads, it does break interoperability with some sites that worked with previous Wget versions, particularly those using self- signed, expired, or otherwise invalid certificates. This option forces an \"insecure\" mode of operation that turns the certificate verification errors into warnings and allows you to proceed. If you encounter \"certificate verification\" errors or ones saying that \"common name doesn't match requested host name\", you can use this option to bypass the verification and proceed with the download. Only use this option if you are otherwise convinced of the site's authenticity, or if you really don't care about the validity of its certificate. It is almost always a bad idea not to check the certificates when transmitting confidential or important data. For self-signed/internal certificates, you should download the certificate and verify against that instead of forcing this insecure mode. If you are really sure of not desiring any certificate verification, you can specify --check-certificate=quiet to tell wget to not print any warning about invalid certificates, albeit in most cases this is the wrong thing to do."
    },
    {
      "flag": "--no-hsts",
      "description": "Wget supports HSTS (HTTP Strict Transport Security, RFC 6797) by default. Use --no-hsts to make Wget act as a non-HSTS-compliant UA. As a consequence, Wget would ignore all the \"Strict-Transport-Security\" headers, and would not enforce any existing HSTS policy."
    },
    {
      "flag": "--warc-cdx",
      "description": "Write CDX index files."
    },
    {
      "flag": "--no-warc-compression",
      "description": "Do not compress WARC files with GZIP."
    },
    {
      "flag": "--no-warc-digests",
      "description": "Do not calculate SHA1 digests."
    },
    {
      "flag": "--no-warc-keep-log",
      "description": "Do not store the log file in a WARC record."
    },
    {
      "flag": "--no-remove-listing",
      "description": "Don't remove the temporary .listing files generated by FTP retrievals. Normally, these files contain the raw directory listings received from FTP servers. Not removing them can be useful for debugging purposes, or when you want to be able to easily check on the contents of remote server directories (e.g. to verify that a mirror you're running is complete). Note that even though Wget writes to a known filename for this file, this is not a security hole in the scenario of a user making .listing a symbolic link to /etc/passwd or something and asking \"root\" to run Wget in his or her directory. Depending on the options used, either Wget will refuse to write to .listing, making the globbing/recursion/time-stamping operation fail, or the symbolic link will be deleted and replaced with the actual .listing file, or the listing will be written to a .listing.number file. Even though this situation isn't a problem, though, \"root\" should never run Wget in a non-trusted user's directory. A user could do something as simple as linking index.html to /etc/passwd and asking \"root\" to run Wget with -N or -r so the file will be overwritten."
    },
    {
      "flag": "--no-glob",
      "description": "Turn off FTP globbing. Globbing refers to the use of shell-like special characters (wildcards), like *, ?, [ and ] to retrieve more than one file from the same directory at once, like: wget ftp://gnjilux.srk.fer.hr/*.msg By default, globbing will be turned on if the URL contains a globbing character. This option may be used to turn globbing on or off permanently. You may have to quote the URL to protect it from being expanded by your shell. Globbing makes Wget look for a directory listing, which is system-specific. This is why it currently works only with Unix FTP servers (and the ones emulating Unix \"ls\" output)."
    },
    {
      "flag": "--no-passive-ftp",
      "description": "Disable the use of the passive FTP transfer mode. Passive FTP mandates that the client connect to the server to establish the data connection rather than the other way around. If the machine is connected to the Internet directly, both passive and active FTP should work equally well. Behind most firewall and NAT configurations passive FTP has a better chance of working. However, in some rare firewall configurations, active FTP actually works when passive FTP doesn't. If you suspect this to be the case, use this option, or set \"passive_ftp=off\" in your init file."
    },
    {
      "flag": "--preserve-permissions",
      "description": "Preserve remote file permissions instead of permissions set by umask."
    },
    {
      "flag": "--retr-symlinks",
      "description": "By default, when retrieving FTP directories recursively and a symbolic link is encountered, the symbolic link is traversed and the pointed-to files are retrieved. Currently, Wget does not traverse symbolic links to directories to download them recursively, though this feature may be added in the future. When --retr-symlinks=no is specified, the linked-to file is not downloaded. Instead, a matching symbolic link is created on the local file system. The pointed-to file will not be retrieved unless this recursive retrieval would have encountered it separately and downloaded it anyway. This option poses a security risk where a malicious FTP Server may cause Wget to write to files outside of the intended directories through a specially crafted .LISTING file. Note that when retrieving a file (not a directory) because it was specified on the command-line, rather than because it was recursed to, this option has no effect. Symbolic links are always traversed in this case. FTPS Options"
    },
    {
      "flag": "--ftps-implicit",
      "description": "This option tells Wget to use FTPS implicitly. Implicit FTPS consists of initializing SSL/TLS from the very beginning of the control connection. This option does not send an \"AUTH TLS\" command: it assumes the server speaks FTPS and directly starts an SSL/TLS connection. If the attempt is successful, the session continues just like regular FTPS (\"PBSZ\" and \"PROT\" are sent, etc.). Implicit FTPS is no longer a requirement for FTPS implementations, and thus many servers may not support it. If --ftps-implicit is passed and no explicit port number specified, the default port for implicit FTPS, 990, will be used, instead of the default port for the \"normal\" (explicit) FTPS which is the same as that of FTP, 21."
    },
    {
      "flag": "--no-ftps-resume-ssl",
      "description": "Do not resume the SSL/TLS session in the data channel. When starting a data connection, Wget tries to resume the SSL/TLS session previously started in the control connection. SSL/TLS session resumption avoids performing an entirely new handshake by reusing the SSL/TLS parameters of a previous session. Typically, the FTPS servers want it that way, so Wget does this by default. Under rare circumstances however, one might want to start an entirely new SSL/TLS session in every data connection. This is what --no-ftps-resume-ssl is for."
    },
    {
      "flag": "--ftps-clear-data-connection",
      "description": "All the data connections will be in plain text. Only the control connection will be under SSL/TLS. Wget will send a \"PROT C\" command to achieve this, which must be approved by the server."
    },
    {
      "flag": "--ftps-fallback-to-ftp",
      "description": "Fall back to FTP if FTPS is not supported by the target server. For security reasons, this option is not asserted by default. The default behaviour is to exit with an error. If a server does not successfully reply to the initial \"AUTH TLS\" command, or in the case of implicit FTPS, if the initial SSL/TLS connection attempt is rejected, it is considered that such server does not support FTPS. Recursive Retrieval Options"
    },
    {
      "flag": "-r",
      "description": "--recursive Turn on recursive retrieving. The default maximum depth is 5."
    },
    {
      "flag": "-l",
      "description": "depth"
    },
    {
      "flag": "--delete-after",
      "description": "This option tells Wget to delete every single file it downloads, after having done so. It is useful for pre-fetching popular pages through a proxy, e.g.: wget -r -nd --delete-after http://whatever.com/~popular/page/ The -r option is to retrieve recursively, and -nd to not create directories. Note that --delete-after deletes files on the local machine. It does not issue the DELE command to remote FTP sites, for instance. Also note that when --delete-after is specified,"
    },
    {
      "flag": "--convert-links",
      "description": "is ignored, so .orig files are simply not created in the first place."
    },
    {
      "flag": "-k",
      "description": "--convert-links After the download is complete, convert the links in the document to make them suitable for local viewing. This affects not only the visible hyperlinks, but any part of the document that links to external content, such as embedded images, links to style sheets, hyperlinks to non-HTML content, etc. Each link will be changed in one of the two ways: \u2022 The links to files that have been downloaded by Wget will be changed to refer to the file they point to as a relative link. Example: if the downloaded file /foo/doc.html links to /bar/img.gif, also downloaded, then the link in doc.html will be modified to point to ../bar/img.gif. This kind of transformation works reliably for arbitrary combinations of directories. \u2022 The links to files that have not been downloaded by Wget will be changed to include host name and absolute path of the location they point to. Example: if the downloaded file /foo/doc.html links to /bar/img.gif (or to ../bar/img.gif), then the link in doc.html will be modified to point to http://hostname/bar/img.gif. Because of this, local browsing works reliably: if a linked file was downloaded, the link will refer to its local name; if it was not downloaded, the link will refer to its full Internet address rather than presenting a broken link. The fact that the former links are converted to relative links ensures that you can move the downloaded hierarchy to another directory. Note that only at the end of the download can Wget know which links have been downloaded. Because of that, the work done by -k will be performed at the end of all the downloads."
    },
    {
      "flag": "--convert-file-only",
      "description": "This option converts only the filename part of the URLs, leaving the rest of the URLs untouched. This filename part is sometimes referred to as the \"basename\", although we avoid that term here in order not to cause confusion. It works particularly well in conjunction with --adjust-extension, although this coupling is not enforced. It proves useful to populate Internet caches with files downloaded from different hosts. Example: if some link points to //foo.com/bar.cgi?xyz with --adjust-extension asserted and its local destination is intended to be ./foo.com/bar.cgi?xyz.css, then the link would be converted to //foo.com/bar.cgi?xyz.css. Note that only the filename part has been modified. The rest of the URL has been left untouched, including the net path (\"//\") which would otherwise be processed by Wget and converted to the effective scheme (ie. \"http://\")."
    },
    {
      "flag": "-K",
      "description": "--backup-converted When converting a file, back up the original version with a .orig suffix. Affects the behavior of -N."
    },
    {
      "flag": "-m",
      "description": "--mirror Turn on options suitable for mirroring. This option turns on recursion and time-stamping, sets infinite recursion depth and keeps FTP directory listings. It is currently equivalent to"
    },
    {
      "flag": "-r",
      "description": "-N -l inf --no-remove-listing."
    },
    {
      "flag": "-p",
      "description": "--page-requisites This option causes Wget to download all the files that are necessary to properly display a given HTML page. This includes such things as inlined images, sounds, and referenced stylesheets. Ordinarily, when downloading a single HTML page, any requisite documents that may be needed to display it properly are not downloaded. Using -r together with -l can help, but since Wget does not ordinarily distinguish between external and inlined documents, one is generally left with \"leaf documents\" that are missing their requisites. For instance, say document 1.html contains an \"<IMG>\" tag referencing 1.gif and an \"<A>\" tag pointing to external document 2.html. Say that 2.html is similar but that its image is 2.gif and it links to 3.html. Say this continues up to some arbitrarily high number. If one executes the command: wget -r -l 2 http://<site>/1.html then 1.html, 1.gif, 2.html, 2.gif, and 3.html will be downloaded. As you can see, 3.html is without its requisite 3.gif because Wget is simply counting the number of hops (up to 2) away from 1.html in order to determine where to stop the recursion. However, with this command: wget -r -l 2 -p http://<site>/1.html all the above files and 3.html's requisite 3.gif will be downloaded. Similarly, wget -r -l 1 -p http://<site>/1.html will cause 1.html, 1.gif, 2.html, and 2.gif to be downloaded. One might think that: wget -r -l 0 -p http://<site>/1.html would download just 1.html and 1.gif, but unfortunately this is not the case, because -l 0 is equivalent to -l inf---that is, infinite recursion. To download a single HTML page (or a handful of them, all specified on the command-line or in a -i URL input file) and its (or their) requisites, simply leave off -r and -l: wget -p http://<site>/1.html Note that Wget will behave as if -r had been specified, but only that single page and its requisites will be downloaded. Links from that page to external documents will not be followed. Actually, to download a single page and all its requisites (even if they exist on separate websites), and make sure the lot displays properly locally, this author likes to use a few options in addition to -p: wget -E -H -k -K -p http://<site>/<document> To finish off this topic, it's worth knowing that Wget's idea of an external document link is any URL specified in an \"<A>\" tag, an \"<AREA>\" tag, or a \"<LINK>\" tag other than \"<LINK REL=\"stylesheet\">\"."
    },
    {
      "flag": "--strict-comments",
      "description": "Turn on strict parsing of HTML comments. The default is to terminate comments at the first occurrence of -->. According to specifications, HTML comments are expressed as SGML declarations. Declaration is special markup that begins with <! and ends with >, such as <!DOCTYPE ...>, that may contain comments between a pair of -- delimiters. HTML comments are \"empty declarations\", SGML declarations without any non-comment text. Therefore, <!--foo--> is a valid comment, and so is <!--one-- --two-->, but <!--1--2--> is not. On the other hand, most HTML writers don't perceive comments as anything other than text delimited with <!-- and -->, which is not quite the same. For example, something like <!------------> works as a valid comment as long as the number of dashes is a multiple of four (!). If not, the comment technically lasts until the next --, which may be at the other end of the document. Because of this, many popular browsers completely ignore the specification and implement what users have come to expect: comments delimited with <!-- and -->. Until version 1.9, Wget interpreted comments strictly, which resulted in missing links in many web pages that displayed fine in browsers, but had the misfortune of containing non- compliant comments. Beginning with version 1.9, Wget has joined the ranks of clients that implements \"naive\" comments, terminating each comment at the first occurrence of -->. If, for whatever reason, you want strict comment parsing, use this option to turn it on. Recursive Accept/Reject Options"
    },
    {
      "flag": "-A",
      "description": "acclist --accept acclist"
    },
    {
      "flag": "-R",
      "description": "rejlist --reject rejlist Specify comma-separated lists of file name suffixes or patterns to accept or reject. Note that if any of the wildcard characters, *, ?, [ or ], appear in an element of acclist or rejlist, it will be treated as a pattern, rather than a suffix. In this case, you have to enclose the pattern into quotes to prevent your shell from expanding it, like in -A \"*.mp3\" or"
    },
    {
      "flag": "-A",
      "description": "'*.mp3'."
    },
    {
      "flag": "--accept-regex",
      "description": "urlregex"
    },
    {
      "flag": "--reject-regex",
      "description": "urlregex Specify a regular expression to accept or reject the complete URL."
    },
    {
      "flag": "--regex-type",
      "description": "regextype Specify the regular expression type. Possible types are posix or pcre. Note that to be able to use pcre type, wget has to be compiled with libpcre support."
    },
    {
      "flag": "-D",
      "description": "domain-list"
    },
    {
      "flag": "--exclude-domains",
      "description": "domain-list Specify the domains that are not to be followed."
    },
    {
      "flag": "--follow-ftp",
      "description": "Follow FTP links from HTML documents. Without this option, Wget will ignore all the FTP links."
    },
    {
      "flag": "--ignore-case",
      "description": "Ignore case when matching files and directories. This influences the behavior of -R, -A, -I, and -X options, as well as globbing implemented when downloading from FTP sites. For example, with this option, -A \"*.txt\" will match file1.txt, but also file2.TXT, file3.TxT, and so on. The quotes in the example are to prevent the shell from expanding the pattern."
    },
    {
      "flag": "-H",
      "description": "--span-hosts Enable spanning across hosts when doing recursive retrieving."
    },
    {
      "flag": "-L",
      "description": "--relative Follow relative links only. Useful for retrieving a specific home page without any distractions, not even those from the same hosts."
    },
    {
      "flag": "-I",
      "description": "list"
    },
    {
      "flag": "-X",
      "description": "list"
    },
    {
      "flag": "-np",
      "description": "--no-parent Do not ever ascend to the parent directory when retrieving recursively. This is a useful option, since it guarantees that only the files below a certain hierarchy will be downloaded. ENVIRONMENT Wget supports proxies for both HTTP and FTP retrievals. The standard way to specify proxy location, which Wget recognizes, is using the following environment variables: http_proxy https_proxy If set, the http_proxy and https_proxy variables should contain the URLs of the proxies for HTTP and HTTPS connections respectively. ftp_proxy This variable should contain the URL of the proxy for FTP connections. It is quite common that http_proxy and ftp_proxy are set to the same URL. no_proxy This variable should contain a comma-separated list of domain extensions proxy should not be used for. For instance, if the value of no_proxy is .mit.edu, proxy will not be used to retrieve documents from MIT. EXIT STATUS Wget may return one of several error codes if it encounters problems. 0 No problems occurred. 1 Generic error code. 2 Parse error---for instance, when parsing command-line options, the .wgetrc or .netrc... 3 File I/O error. 4 Network failure. 5 SSL verification failure. 6 Username/password authentication failure. 7 Protocol errors. 8 Server issued an error response. With the exceptions of 0 and 1, the lower-numbered exit codes take precedence over higher-numbered ones, when multiple types of errors are encountered. In versions of Wget prior to 1.12, Wget's exit status tended to be unhelpful and inconsistent. Recursive downloads would virtually always return 0 (success), regardless of any issues encountered, and non-recursive fetches only returned the status corresponding to the most recently-attempted download. FILES /etc/wgetrc Default location of the global startup file. .wgetrc User startup file. BUGS You are welcome to submit bug reports via the GNU Wget bug tracker (see <https://savannah.gnu.org/bugs/?func=additem&group=wget>) or to our mailing list <bug-wget@gnu.org>. Visit <https://lists.gnu.org/mailman/listinfo/bug-wget> to get more info (how to subscribe, list archives, ...). Before actually submitting a bug report, please try to follow a few simple guidelines. 1. Please try to ascertain that the behavior you see really is a bug. If Wget crashes, it's a bug. If Wget does not behave as documented, it's a bug. If things work strange, but you are not sure about the way they are supposed to work, it might well be a bug, but you might want to double-check the documentation and the mailing lists. 2. Try to repeat the bug in as simple circumstances as possible. E.g. if Wget crashes while downloading wget -rl0 -kKE -t5 --no-proxy http://example.com -o /tmp/log, you should try to see if the crash is repeatable, and if will occur with a simpler set of options. You might even try to start the download at the page where the crash occurred to see if that page somehow triggered the crash. Also, while I will probably be interested to know the contents of your .wgetrc file, just dumping it into the debug message is probably a bad idea. Instead, you should first try to see if the bug repeats with .wgetrc moved out of the way. Only if it turns out that .wgetrc settings affect the bug, mail me the relevant parts of the file. 3. Please start Wget with -d option and send us the resulting output (or relevant parts thereof). If Wget was compiled without debug support, recompile it---it is much easier to trace bugs with debug support on. Note: please make sure to remove any potentially sensitive information from the debug log before sending it to the bug address. The \"-d\" won't go out of its way to collect sensitive information, but the log will contain a fairly complete transcript of Wget's communication with the server, which may include passwords and pieces of downloaded data. Since the bug address is publicly archived, you may assume that all bug reports are visible to the public. 4. If Wget has crashed, try to run it in a debugger, e.g. \"gdb `which wget` core\" and type \"where\" to get the backtrace. This may not work if the system administrator has disabled core files, but it is safe to try."
    }
  ],
  "examples": [],
  "see_also": [
    "wget2",
    "WGET"
  ],
  "last_updated": "2025-09-14T22:01:58",
  "machine_id": "linux_7618b026bd4e"
}