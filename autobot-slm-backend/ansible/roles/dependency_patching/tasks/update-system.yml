# AutoBot - AI-Powered Automation Platform
# Copyright (c) 2025 mrveiss
# Author: mrveiss
---
# System Package Update Tasks (apt)
# Issue #682: Rolling system updates with backup and rollback

- name: Get current service definition
  ansible.builtin.set_fact:
    current_service: "{{ service_definitions[group_names | first] | default({}) }}"

- name: Pre-update - Get list of upgradable packages
  ansible.builtin.command:
    cmd: apt list --upgradable
  register: upgradable_packages
  changed_when: false

- name: Log upgradable packages
  ansible.builtin.debug:
    msg: |
      Upgradable packages on {{ inventory_hostname }}:
      {{ upgradable_packages.stdout_lines | join('\n') }}
  when: upgradable_packages.stdout_lines | length > 1

- name: Skip if no updates available
  ansible.builtin.debug:
    msg: "No system updates available on {{ inventory_hostname }}"
  when: upgradable_packages.stdout_lines | length <= 1

# Only proceed if updates are available
- name: System update block
  block:
    - name: Create backup directory
      ansible.builtin.file:
        path: "{{ backup_base_path }}/system"
        state: directory
        mode: "0700"
      when: backup_enabled

    - name: Get dpkg package state
      ansible.builtin.command:
        cmd: dpkg --get-selections
      register: dpkg_selections
      changed_when: false
      when: backup_enabled

    - name: Write dpkg selections to backup file
      ansible.builtin.copy:
        content: "{{ dpkg_selections.stdout }}"
        dest: "{{ backup_base_path }}/system/dpkg-selections-{{ ansible_date_time.iso8601_basic }}.txt"
        mode: "0600"
      when: backup_enabled
      register: dpkg_backup

    - name: Backup apt sources list
      ansible.builtin.copy:
        src: /etc/apt/sources.list
        dest: "{{ backup_base_path }}/system/sources.list-{{ ansible_date_time.iso8601_basic }}"
        remote_src: yes
      when: backup_enabled

    - name: Record pre-update state
      ansible.builtin.set_fact:
        pre_system_update_state:
          host: "{{ inventory_hostname }}"
          backup_created: "{{ dpkg_backup.changed | default(false) }}"
          backup_path: "{{ backup_base_path }}/system/dpkg-selections-{{ ansible_date_time.iso8601_basic }}.txt"
          upgradable_count: "{{ (upgradable_packages.stdout_lines | length) - 1 }}"
          timestamp: "{{ ansible_date_time.iso8601 }}"

    - name: Stop service before system update
      ansible.builtin.systemd:
        name: "{{ current_service.service_name }}"
        state: stopped
      when:
        - current_service.service_name is defined
        - drain_enabled
      ignore_errors: yes
      register: service_stopped

    - name: Wait for service to drain
      ansible.builtin.pause:
        seconds: "{{ drain_timeout }}"
      when:
        - service_stopped.changed | default(false)
        - drain_enabled

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: yes
        cache_valid_time: 300
      register: apt_cache_result
      retries: 3
      delay: 10
      until: apt_cache_result is succeeded

    - name: Fail if apt cache update failed
      ansible.builtin.fail:
        msg: "CRITICAL: apt cache update failed on {{ inventory_hostname }}. Check network and repository availability."
      when: apt_cache_result is failed

    - name: Perform security updates only
      ansible.builtin.apt:
        upgrade: safe
        default_release: "{{ ansible_distribution_release }}-security"
      when: security_only | default(false)
      register: security_update_result
      timeout: "{{ system_update_timeout }}"

    - name: Perform full system update
      ansible.builtin.apt:
        upgrade: safe
        autoremove: yes
        autoclean: yes
      when: not (security_only | default(false))
      register: full_update_result
      timeout: "{{ system_update_timeout }}"

    - name: Set update result
      ansible.builtin.set_fact:
        system_update_result: "{{ security_update_result if (security_only | default(false)) else full_update_result }}"

    - name: Check if reboot is required
      ansible.builtin.stat:
        path: /var/run/reboot-required
      register: reboot_required

    - name: Log reboot required status
      ansible.builtin.debug:
        msg: "⚠️ REBOOT REQUIRED on {{ inventory_hostname }} - Kernel or critical library updated"
      when: reboot_required.stat.exists

    - name: Reboot if required and allowed
      ansible.builtin.reboot:
        reboot_timeout: 300
        msg: "AutoBot rolling update - rebooting for system updates"
      when:
        - reboot_required.stat.exists
        - reboot_if_required | default(false)
      register: reboot_result

    - name: Wait for system to come back up after reboot
      ansible.builtin.wait_for_connection:
        timeout: 300
        delay: 10
      when: reboot_result.changed | default(false)

    - name: Restart service after system update
      ansible.builtin.systemd:
        name: "{{ current_service.service_name }}"
        state: started
        daemon_reload: yes
      when:
        - current_service.service_name is defined
        - restart_service_after_update
      register: service_restart

    - name: Wait for service to stabilize
      ansible.builtin.pause:
        seconds: "{{ service_restart_delay }}"
      when: service_restart.changed | default(false)

    - name: Verify service health (HTTP endpoint)
      ansible.builtin.uri:
        url: "http://localhost:{{ current_service.health_port }}{{ current_service.health_endpoint }}"
        method: GET
        status_code: 200
        timeout: "{{ health_check_timeout }}"
      register: health_check
      until: health_check.status == 200
      retries: "{{ health_check_retries }}"
      delay: "{{ health_check_delay }}"
      when:
        - health_check_enabled
        - current_service.health_endpoint is defined
        - current_service.health_endpoint is not none

    - name: Verify Redis health (for database group)
      ansible.builtin.command:
        cmd: redis-cli ping
      register: redis_health
      until: redis_health.stdout == "PONG"
      retries: "{{ health_check_retries }}"
      delay: "{{ health_check_delay }}"
      when:
        - health_check_enabled
        - "'database' in group_names"
      changed_when: false

    - name: Log successful system update
      ansible.builtin.debug:
        msg: |
          System update completed on {{ inventory_hostname }}
          Packages updated: {{ (upgradable_packages.stdout_lines | length) - 1 }}
          Reboot required: {{ reboot_required.stat.exists }}
          Reboot performed: {{ reboot_result.changed | default(false) }}
          Service running: {{ service_restart.changed | default('N/A') }}
          Health check: {{ 'PASSED' if not (health_check.failed | default(false)) else 'N/A' }}

  rescue:
    - name: Log system update failure
      ansible.builtin.debug:
        msg: "FAILED: System update on {{ inventory_hostname }}. Initiating rollback..."

    - name: Restore service if stopped
      ansible.builtin.systemd:
        name: "{{ current_service.service_name }}"
        state: started
      when:
        - current_service.service_name is defined
        - service_stopped.changed | default(false)
      ignore_errors: yes

    - name: Include system rollback tasks
      ansible.builtin.include_tasks: rollback-system.yml
      when: rollback_on_failure

    - name: Fail the play after rollback attempt
      ansible.builtin.fail:
        msg: "System update failed on {{ inventory_hostname }}. Rollback {{ 'attempted' if rollback_on_failure else 'skipped' }}."

  when: upgradable_packages.stdout_lines | length > 1

- name: Record post-update state
  ansible.builtin.set_fact:
    post_system_update_state:
      host: "{{ inventory_hostname }}"
      success: true
      packages_updated: "{{ (upgradable_packages.stdout_lines | length) - 1 }}"
      reboot_required: "{{ reboot_required.stat.exists | default(false) }}"
      reboot_performed: "{{ reboot_result.changed | default(false) }}"
      service_running: "{{ service_restart.changed | default(false) }}"
      health_check_passed: "{{ not (health_check.failed | default(false)) }}"
      timestamp: "{{ ansible_date_time.iso8601 }}"
